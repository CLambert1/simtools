# WARNING - Generated by {fusen} from dev/flat_simulate_mvmt.Rmd: do not edit by hand

#' Simulate individual trajectory
#'
#' Simulate the trajectory of a free ranging individual, over a given time period. The function works similarly as \code{\link{simulate_trajectory_CPF}} but the individual is not restrained around a colony and does not perform homing bout. Here, `potential_position_func()` considers the initial position as the colony, so that the dist_col field in the output corresponds to the distance to this starting point. 
#'
#' @param initial_position data.frame containing the coordinates of the point the individual starts from (Lon, Lat fields)
#' @param resource_layer SpatRaster of the resource layer
#' @param starting_hour Starting hour
#' @param starting_bearing Bearing when departing the colony (mu, kappa)
#' @param starting_step Step length when departing the colony (mu, kappa)
#' @param travel_bearing Bearing from previous step when traveling (mu, kappa)
#' @param travel_step Distance from previous step when traveling (scale, rate) 
#' @param foraging_bearing Bearing from previous step when foraging/searching (mu, kappa)
#' @param foraging_step Distance from previous step when foraging (scale, rate)
#' @param minx Minimum longitude of the bounding box to simulate trajectory within
#' @param maxx Maximum longitude of the bounding box to simulate trajectory within
#' @param miny Minimum latitude of the bounding box to simulate trajectory within
#' @param maxy Maximum latitude of the bounding box to simulate trajectory within
#' @param max_duration Total duration of a full trip, in minutes (defaults to 720, 12h)
#' @param step_duration Duration of a step length, in minutes (defaults 1), defines the sampling interval
#' @param activity_threshold Threshold environmental value defining when an individual switches from travelling to foraging movement
#' @param residence_radius The distance at which testing for residence time (in system unit). This value is used to draw a radius around each position to evaluate the residence time. If one of `residence_radius` and `residence_time` is NULL (both, by default), no residence time constraint is applied. 
#' @param residence_time The time an animal is allowed to spend in a same area (residence time). Expressed in number of steps (take care to provide a number of step consistent with `step_duration`). If one of `residence_radius` and `residence_time` is NULL (both, by default), no residence time constraint is applied. 
#' 
#' @import lubridate
#' @importFrom dplyr full_join slice_sample slice_head desc arrange
#' @importFrom sf st_as_sf st_buffer st_within
#' @importFrom fields rdist
#' 
#' @family individual movement functions
#' 
#' @return a data.frame
#' @export
#'
#' @examples
#' library(ggplot2)
#' library(viridis)
#' library(tidyterra)
#' library(lubridate)
#' colony_location <- data.frame(Lon = 50, Lat = 50)
#' cdt <- generate_env_layer(grid = create_grid(), n = 1, seed = 4)
#'     
#' single_traj <- simulate_trajectory_FR(initial_position = colony_location, 
#'                     resource_layer = cdt$rasters, 
#'                     starting_hour = ymd_hms("2022-08-02 06:00:00"),
#'                     starting_bearing = c(90,10), 
#'                     starting_step = c(4.5, 3),
#'                     travel_bearing = c(0, 20), 
#'                     travel_step = c(3, 3), 
#'                     foraging_bearing = c(0, 0.5), 
#'                     foraging_step = c(1, 3),
#'                     minx = 0, maxx = 90, 
#'                     miny = 0, maxy = 90,
#'                     step_duration = 1,
#'                     activity_threshold = 0.7,
#'                     max_duration = 2000,
#'                     residence_radius = 1,
#'                     residence_time = 20)
#'
#' # view the trajectory
#' ggplot(single_traj) +
#'   geom_spatraster(data = cdt$rasters, alpha = 0.5) + 
#'   geom_point(aes(x = Lon, y = Lat, color = activity)) +
#'   geom_point(data = colony_location, aes(x = Lon, y = Lat), col = "red") +
#'   scale_fill_viridis(option = "H") 
#'
#' # look at the density distribution of distance to colony and movement parameters
#' ggplot(single_traj) + geom_density(aes(x = dist_col))
#' ggplot(single_traj |> subset(activity %in% c("forage", "travel"))) + 
#'   geom_density(aes(x = angle)) + facet_wrap("activity")
#' ggplot(single_traj |> subset(activity %in% c("forage", "travel"))) + 
#'   geom_density(aes(x = step)) + facet_wrap("activity")
#'
#'
simulate_trajectory_FR <- function(initial_position, 
                                resource_layer, 
                       starting_hour,
                       starting_bearing = c(90,10),
                       starting_step = c(4.5, 3),
                       travel_bearing = c(0, 20), # (mu, kappa) -> higher kappa = higher concentration
                       travel_step = c(3, 3), #  (scale, rate) -> smaller the rate, higher the dispersion
                       foraging_bearing = c(0, 0.5), 
                       foraging_step = c(1, 3), 
                       minx = 0, maxx = 90, 
                       miny = 0, maxy = 90,
                       step_duration = 1,
                       activity_threshold = 0.5,
                       max_duration = 720,
                       residence_radius = NULL,
                       residence_time = NULL) 
{
    if(isFALSE(initial_position$Lon >= minx & initial_position$Lon <= maxx &
         initial_position$Lat >= miny & initial_position$Lat <= maxy)){
    stop("initial_position must be included in the bounding box given by minx, maxx, miny and maxy")
  }
  ext_coord <- as.vector(terra::ext(resource_layer))
  if(isFALSE(initial_position$Lon >= ext_coord[[1]] & initial_position$Lon <= ext_coord[[2]] &
            initial_position$Lat >= ext_coord[[3]] & initial_position$Lat <= ext_coord[[4]])){
    stop("initial_position must be included in the resource_layer extent")
  }
  if(nrow(initial_position) != 1){
    stop("initial_position must include a single row")
  }
  
  track_output <- data.frame(Lon = initial_position$Lon,
                             Lat = initial_position$Lat,
                             angle = NA,
                             step = 0,
                             env = NA,
                             dist_col = 0,
                             activity = "start",
                             stepID = 0,
                             ymd_hms = starting_hour,
                             x_from = initial_position$Lon,
                             y_from = initial_position$Lat,
                             date_from = starting_hour)
  
  ### Departs from the colony - outbound phase of travel and foraging bouts
  i <- 2
  while(track_output[i-1, "ymd_hms"] < ymd_hms(starting_hour) + lubridate::minutes(max_duration)
  ){
    # starts with the initial bearing
    if(i == 2){ 
      potential_position <- NULL
      while(is.null(nrow(potential_position))) { # if no points possible then do it again
        potential_position <- potential_position_func(n = 10, 
                                                      bearing = starting_bearing, 
                                                      step = starting_step, 
                                                      from = track_output[i - 1, ],
                                                      colony_location = initial_position, 
                                                      resource_layer = resource_layer) |>
          subset(Lon < maxx & Lon > minx) |>
          subset(Lat < maxy & Lat > miny) |>
          dplyr::slice_sample(n = 1)
        } 
      track_output[i, c("Lon","Lat","angle","step","env","dist_col")] <- potential_position[, c("Lon","Lat","angle","step","env","dist_col")]
      track_output[i, "stepID"] <-  track_output[i-1, "stepID"] + 1
      track_output[i, "ymd_hms"] <-  track_output[i-1, "ymd_hms"] + lubridate::minutes(step_duration)
      track_output[i, "x_from"] <-  track_output[i-1, "Lon"]
      track_output[i, "y_from"] <-  track_output[i-1, "Lat"]
      track_output[i, "date_from"] <-  track_output[i-1, "ymd_hms"]
      track_output[i, "activity"] <- "travel"
    }
    # continue with traveling parameters but not yet condition on environment
    if(i %in% c(3:5)){
      potential_position <- NULL
      while(is.null(nrow(potential_position))) { # if no points possible then do it again
        potential_position <- potential_position_func(n = 10, 
                                                      bearing = travel_bearing, 
                                                      step = travel_step, 
                                                      from = track_output[i - 1, ],
                                                      colony_location = initial_position, 
                                                      resource_layer = resource_layer) |>
          subset(Lon < maxx & Lon > minx) |>
          subset(Lat < maxy & Lat > miny) |>
          dplyr::slice_sample(n = 1) 
      } 
      track_output[i, c("Lon","Lat","angle","step","env","dist_col")] <- potential_position[, c("Lon","Lat","angle","step","env","dist_col")]
      track_output[i, "stepID"] <-  track_output[i-1, "stepID"] + 1
      track_output[i, "ymd_hms"] <-  track_output[i-1, "ymd_hms"] + lubridate::minutes(step_duration)
      track_output[i, "x_from"] <-  track_output[i-1, "Lon"]
      track_output[i, "y_from"] <-  track_output[i-1, "Lat"]
      track_output[i, "date_from"] <-  track_output[i-1, "ymd_hms"]
      track_output[i, "activity"] <- "travel"
    }else{
    ### Starts foraging bouts
      # sample potential positions based on movement type of previous step and select next step based on environment
      if(track_output[i-1, "activity"] == "travel"){

        if(all(isFALSE(is.null(residence_time)), isFALSE(is.null(residence_radius)), isTRUE(i>residence_time))){
          # check for residence time only when both parameters are provided and 
          # when i is largest than the residence time
          buf <- track_output[i-1,] |> 
            sf::st_as_sf(coords = c("Lon", "Lat")) |> 
            sf::st_buffer(dist = residence_radius)
          previous_positions <- track_output[c(i-(residence_time+1), i-2), ] |> 
            sf::st_as_sf(coords = c("Lon", "Lat")) 
          
          if(isTRUE(all(sf::st_within(previous_positions, buf, sparse = F)))){ # if all points during the residence time interval are within the residence radius, then subset the one point farthest from the previous step
            # sample potential points
            potential_position <- NULL
            while(is.null(nrow(potential_position))) { # if table is empty then do it again
              potential_position <- potential_position_func(n = 10, 
                                                            bearing = travel_bearing, 
                                                            step = travel_step, 
                                                            from = track_output[i - 1, ],
                                                            colony_location = initial_position, 
                                                            resource_layer = resource_layer) |>
                  subset(Lon < maxx & Lon > minx) |>
                  subset(Lat < maxy & Lat > miny)
            } 
            # extract the ones outside the residence_radius
            potential_position_sf <- potential_position |> 
              mutate(x = Lon, y = Lat) |> 
              sf::st_as_sf(coords = c("x", "y")) 
            # if all potential position fall within the radius, choose based on distance (farthest from prev point)
            if(isTRUE(all(sf::st_within(potential_position_sf, buf, sparse = F)))){
              potential_position$dist_from_previous <- as.vector(fields::rdist(track_output[i-1, c("Lon", "Lat")], 
                                                                 potential_position[, c("Lon", "Lat")]))
              potential_position <- potential_position |> 
                dplyr::arrange(dplyr::desc(dist_from_previous)) |> 
                dplyr::slice_head(n = 1)
            }else{ # if some are outside, extract it and take the best env value
              potential_position <- potential_position_sf[ !(sf::st_within(potential_position_sf, buf, sparse = F)) , ] |>
              sf::st_drop_geometry()
              potential_position <- potential_position |> 
                dplyr::arrange(dplyr::desc(env)) |> 
                dplyr::slice_head(n = 1)
            }
          } else {
            potential_position <- NULL
            while(is.null(nrow(potential_position))) { # if table is empty then do it again
              potential_position <- potential_position_func(n = 10, 
                                                            bearing = travel_bearing, 
                                                            step = travel_step, 
                                                            from = track_output[i - 1, ],
                                                            colony_location = initial_position, 
                                                            resource_layer = resource_layer) |>
                  subset(Lon < maxx & Lon > minx) |>
                  subset(Lat < maxy & Lat > miny)|>
              dplyr::arrange(dplyr::desc(env)) |> # decreasing according to env values
              dplyr::slice_head(n = 4)
            } 
          potential_position <- potential_position |> dplyr::slice_sample(n = 1)
          }
        } else {
          potential_position <- NULL
          while(is.null(nrow(potential_position))) { # if table is empty then do it again
              potential_position <- potential_position_func(n = 10, 
                                                            bearing = travel_bearing, 
                                                            step = travel_step, 
                                                            from = track_output[i - 1, ],
                                                            colony_location = initial_position, 
                                                            resource_layer = resource_layer) |>
                  subset(Lon < maxx & Lon > minx) |>
                  subset(Lat < maxy & Lat > miny)|>
              dplyr::arrange(dplyr::desc(env)) |> # decreasing according to env values
              dplyr::slice_head(n = 4)
            } 
          potential_position <- potential_position |> dplyr::slice_sample(n = 1)
        }
      }
      if(track_output[i-1, "activity"] == "forage"){
          if(all(isFALSE(is.null(residence_time)), isFALSE(is.null(residence_radius)), isTRUE(i>residence_time))){
          # check for residence time only when both parameters are provided and 
          # when i is largest than the residence time
          buf <- track_output[i-1,] |> 
            sf::st_as_sf(coords = c("Lon", "Lat")) |> 
            sf::st_buffer(dist = residence_radius)
          previous_positions <- track_output[c(i-(residence_time+1), i-2), ] |> 
            sf::st_as_sf(coords = c("Lon", "Lat")) 
          
          if(isTRUE(all(sf::st_within(previous_positions, buf, sparse = F)))){ # if all points during the residence time interval are within the residence radius, then subset the one point farthest from the previous step
            # sample potential points
            potential_position <- NULL
            while(is.null(nrow(potential_position))) { # if table is empty then do it again
              potential_position <- potential_position_func(n = 10, 
                                                            bearing = foraging_bearing, 
                                                            step = foraging_step, 
                                                            from = track_output[i - 1, ],
                                                            colony_location = initial_position, 
                                                            resource_layer = resource_layer) |>
                  subset(Lon < maxx & Lon > minx) |>
                  subset(Lat < maxy & Lat > miny)
            } 
            # extract the ones outside the residence_radius
            potential_position_sf <- potential_position |> 
              mutate(x = Lon, y = Lat) |> 
              sf::st_as_sf(coords = c("x", "y")) 
            # if all potential position fall within the radius, choose based on distance (farthest from prev point)
            if(isTRUE(all(sf::st_within(potential_position_sf, buf, sparse = F)))){
              potential_position$dist_from_previous <- as.vector(fields::rdist(track_output[i-1, c("Lon", "Lat")], 
                                                                 potential_position[, c("Lon", "Lat")]))
              potential_position <- potential_position |> 
                dplyr::arrange(dplyr::desc(dist_from_previous)) |> 
                dplyr::slice_head(n = 1)
            }else{ # if some are outside, extract it and take the best env value
              potential_position <- potential_position_sf[ !(sf::st_within(potential_position_sf, buf, sparse = F)) , ] |>
              sf::st_drop_geometry()
              potential_position <- potential_position |> 
                dplyr::arrange(dplyr::desc(env)) |> 
                dplyr::slice_head(n = 1)
            }
          } else {
            potential_position <- NULL
            while(is.null(nrow(potential_position))) { # if table is empty then do it again
              potential_position <- potential_position_func(n = 10, 
                                                            bearing = foraging_bearing, 
                                                            step = foraging_step, 
                                                            from = track_output[i - 1, ],
                                                            colony_location = initial_position, 
                                                            resource_layer = resource_layer) |>
                  subset(Lon < maxx & Lon > minx) |>
                  subset(Lat < maxy & Lat > miny)|>
              dplyr::arrange(dplyr::desc(env)) |> # decreasing according to env values
              dplyr::slice_head(n = 4)
            } 
          potential_position <- potential_position |> dplyr::slice_sample(n = 1)
          }
        } else {
          potential_position <- NULL
          while(is.null(nrow(potential_position))) { # if table is empty then do it again
              potential_position <- potential_position_func(n = 10, 
                                                            bearing = foraging_bearing, 
                                                            step = foraging_step, 
                                                            from = track_output[i - 1, ],
                                                            colony_location = initial_position, 
                                                            resource_layer = resource_layer) |>
                  subset(Lon < maxx & Lon > minx) |>
                  subset(Lat < maxy & Lat > miny)|>
              dplyr::arrange(dplyr::desc(env)) |> # decreasing according to env values
              dplyr::slice_head(n = 4)
            } 
          potential_position <- potential_position |> dplyr::slice_sample(n = 1)
        }
      }

      track_output[i, c("Lon","Lat","angle","step","env","dist_col")] <- potential_position[, c("Lon","Lat","angle","step","env","dist_col")]
      track_output[i, "stepID"] <-  track_output[i-1, "stepID"] + 1
      track_output[i, "ymd_hms"] <-  track_output[i-1, "ymd_hms"] + lubridate::minutes(step_duration)
      track_output[i, "x_from"] <-  track_output[i-1, "Lon"]
      track_output[i, "y_from"] <-  track_output[i-1, "Lat"]
      track_output[i, "date_from"] <-  track_output[i-1, "ymd_hms"]
      # evaluate whether traveling or foraging (if env >= 0.5 = switch) for next step
      track_output[i, "activity"] <- ifelse( potential_position$env >= activity_threshold, "forage", "travel") 
    }
    i = i +1  
    }
  return(track_output)
}
# inherits checks for potential.positions
