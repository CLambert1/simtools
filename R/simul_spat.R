# WARNING - Generated by {fusen} from dev/flat_simulate_sp.Rmd: do not edit by hand

#' Simulate spatial point process
#' 
#' Generates a spatial point process from a reference map, using Inhomogeneous Poisson Point Process with spatstat IPP. The intensity of the process is proportional to this reference map, and the final number of individuals in the population is provided by N. Several runs can be simulated at the same time. If working in a real environment, reference map must be projected.
#'
#' @param ref_map Reference map, must be projected
#' @param N Number of individuals in the final population
#' @param seed Numeric
#' @param n_sim Number of simulation to run
#' @param return_wgs_coordinates Boolean. Should the function returns points in WGS coordinates? Recommended when working on real environment
#' @param drop_geometry Boolean. Should the geometry be dropped in returned object? Defaults to FALSE, if TRUE the function will return a data.frame and not a sf object. 
#' @param mean_group_size The mean group size to generate the mark. Set to NULL if no mark is wanted.
#' 
#' @import sf 
#' @importFrom purrr map_df 
#' @importFrom tibble tibble
#' @importFrom terra as.data.frame
#' @importFrom tidyr drop_na
#' @importFrom spatstat.geom as.im
#' 
#' @seealso \code{\link{generate_resource_layer()}} \code{\link{generate_env_layers()}}
#' 
#' @return Returns an sf object
#' @export
#'
#' @examples
#' grid <- create_grid()
#' cdt <- generate_env_layer(grid = grid)
#' rsce <- generate_resource_layer(env_layers = cdt$rasters,
#'                             beta = c(2, -1.5))
#'
#' # issue a warning: we are in a virtual env and ref_map has no crs
#' out <- simul_spat(ref_map = rsce$rasters, n_sim = 2, 
#'                   return_wgs_coordinates = FALSE, N = 1000, mean_group_size = 10)
#'
#' ggplot2::ggplot(out) +
#'   ggplot2::geom_tile(data = rsce$dataframe, ggplot2::aes(x = x, y = y, fill = suitability)) + 
#'   ggplot2::geom_sf() + ggplot2::facet_wrap("name") +
#'   viridis::scale_fill_viridis(option = "H")
#'
#' ggplot2::ggplot(out) +
#'    ggplot2::geom_sf(ggplot2::aes(size = size)) + ggplot2::facet_wrap("name") 
#'
simul_spat <- function(ref_map, 
                       N,
                       seed = NULL,
                       n_sim = 1, 
                       return_wgs_coordinates = TRUE,
                       drop_geometry = FALSE,
                       mean_group_size = NULL
) {
  # check whether ref_map is projected
  if(isTRUE(sf::st_is_longlat(ref_map))){
    stop("ref_map must be in projected coordinates.")
  }
  if(all(is.na(sf::st_is_longlat(ref_map)),
         isTRUE(return_wgs_coordinates))){
    stop("ref_map has no crs, return_wgs_coordinates must be set to FALSE.")
  }
  if(all(is.na(sf::st_is_longlat(ref_map)),
         isFALSE(return_wgs_coordinates))){
    warning("ref_map has no crs, is that voluntary? The output will have no crs.")
  }
  
  # base map to im object
  # https://rdrr.io/cran/maptools/man/as.ppp.html
  df_map <- terra::as.data.frame(ref_map, xy = T)
  df_map <- df_map |> tidyr::drop_na()
  
  X <- spatstat.geom::as.im(df_map)
  # use spatstat.geom::as.im() for class data.frame (sur data.frame(raster))
  
  ### generate observations according to an Inhomogeneous Poisson Point Process with spatstat IPP
  seed <- sample.int(1e6, 1)
  set.seed(seed)
  y_obs <- rpoispp_custom(lambda = X, drop = TRUE, N = N, nsim = n_sim)
  
  if(n_sim == 1) {
    pts <- obs <- data.frame(x = y_obs$x,
                             y = y_obs$y
    )
    pts$obs.id <- 1:nrow(pts)
  } else {
    y_obs <- purrr::map_df(y_obs,
                         ~tibble::tibble(x = .$x, y = .$y),
                         .id = "name")
    pts <- obs <- data.frame(x = y_obs$x,
                            y = y_obs$y,
                            name = y_obs$name
    ) 
    # miss affecting obs id
  }

   # y_obs |> dplyr::group_by(name) |> dplyr::mutate(obs.id = 1:dplyr::tally(.))
   
   
  if(return_wgs_coordinates == TRUE){
    pts <- pts |>
      sf::st_as_sf(coords = c("x", "y"), crs = sf::st_crs(sf::st_crs(ref_map))) |>
      sf::st_transform(crs = sf::st_crs(4326)) 
    pts[, c("lon", "lat")] <- pts |> sf::st_coordinates()
  } else {
    pts <- pts |>
      sf::st_as_sf(coords = c("x", "y"), crs = sf::st_crs(sf::st_crs(ref_map)))
    pts[, c("x", "y")] <- pts |> sf::st_coordinates()
  }

  # affect a mark if mean_group_size is not null
  if(!is.null(mean_group_size)){
    n_obs <- nrow(pts)
    omega <- rep(1, n_obs)
    pts$size <- stats::rpois(n_obs, lambda = (mean_group_size - 1) * omega) + 1
  }
  
  if(drop_geometry == TRUE){
    return(sf::st_drop_geometry(pts))
  } else {
    return(pts)
  }
}
