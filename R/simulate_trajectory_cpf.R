# WARNING - Generated by {fusen} from dev/flat_simulate_mvmt.Rmd: do not edit by hand

#' Simulate individual trajectory
#'
#' Simulate the trajectory of a central-place forager over a given time period. 
#' 
#' @details The individual launches its trip at a given time period (`starting.hour`, `ymd_hms` format) and starts its returning trip either when at a given distance from its colony (provided with `max_dist`) or after a given time period (max_duration). The user can define the bearing and step distributions for the departing step, but also for the travelling and foraging bouts. By default, travelling are set to be directed movement patterns (large steps with low variability, low angles with low variability) and foraging to be area-restricted movements (short steps with low variability, large angles with large variability). The user can define the step duration, that is the time  interval at which the positions are sampled. 
#'    For each position, ten potential subsequent positions are randomly sampled using \code{\link{potential_position_func}}, that is with movement parameters based on the activity the individual is engaged in at the previous step (travelling or foraging). The environmental suitability (a raster layer provided with resource_layer) is retrieved for each potential point based on their geographic coordinates, and their distance from the colony is computed using the `rdist` function from the fields package. 
#'    The first four positions of the track after colony departure are randomly selected within the ten potential points sampled as described above, using travelling movement. Afterwards, residence time is checked for every points: residence time is considered reached when a user-defined number of previous positions (as defined with `residence_time`) fall within the `residence_radius`. If the residence time is reached, the potential subsequent positions falling outside the residence_radius are extracted, and the next position is sampled as the one of them with the highest environmental suitability. If no potential position falls outside the radius (which can be the case when the radius largely exceeds the steps), the next position is the point situated at the largest distance from the previous position in the track. If the residence time is not reached, the subsequent position is randomly sampled among the four out of ten potential points which have the highest values of environmental suitability. If the environmental suitability of the selected subsequent position exceeds a given threshold (`activity_threshold`), the individual switches to foraging movements; if not, the individual continues travelling.
#'    When individuals reaches the threshold distance to colony (`max_dist`), or the trip duration exceeds the given duration (`max_duration`), they start their homeward journey. Potential next positions are sampled using only travelling movement parameters, and the next positions are selected based on the minimum distance to the colony. If several potential positions meet the selection criteria, the next step is randomly sampled within these positions. An individual is considered back when within 0.5 spatial unit (the unit depends on the provided resource layer) from the colony.
#'
#' @param initial_position data.frame containing the coordinates of the point the individual starts from (Lon, Lat fields), considered to be the colony location
#' @param resource_layer SpatRaster of the resource layer
#' @param starting_hour Starting hour
#' @param starting_bearing Bearing when departing the colony (mu, kappa)
#' @param starting_step Step length when departing the colony (mu, kappa)
#' @param travel_bearing Bearing from previous step when traveling (mu, kappa)
#' @param travel_step Distance from previous step when traveling (scale, rate) 
#' @param foraging_bearing Bearing from previous step when foraging/searching (mu, kappa)
#' @param foraging_step Distance from previous step when foraging (scale, rate)
#' @param minx Minimum longitude of the bounding box to simulate trajectory within
#' @param maxx Maximum longitude of the bounding box to simulate trajectory within
#' @param miny Minimum latitude of the bounding box to simulate trajectory within
#' @param maxy Maximum latitude of the bounding box to simulate trajectory within
#' @param max_dist Distance threshold value above which the individual starts its homing bout
#' @param max_duration Total duration of a full trip, in minutes (defaults to 720, 12h)
#' @param step_duration Duration of a step length, in minutes (defaults 1), defines the sampling interval
#' @param activity_threshold Threshold environmental value defining when an individual switches from travelling to foraging movement
#' @param residence_radius The distance at which testing for residence time (in system unit). This value is used to draw a radius around each position to evaluate the residence time. If one of `residence_radius` and `residence_time` is NULL (both, by default), no residence time constraint is applied. 
#' @param residence_time The time an animal is allowed to spend in a same area (residence time). Expressed in number of steps (take care to provide a number of step consistent with `step_duration`). If one of `residence_radius` and `residence_time` is NULL (both, by default), no residence time constraint is applied. 
#' 
#'
#' @import lubridate
#' @importFrom dplyr full_join slice_sample slice_head desc arrange
#' @importFrom sf st_as_sf st_buffer st_within st_drop_geometry
#' @importFrom fields rdist
#' 
#' @return a data.frame
#' @export
#' 
#' @family individual movement functions
#'
#' @examples
#' library(ggplot2)
#' library(viridis)
#' library(tidyterra)
#' library(lubridate)
#' library(terra)
#' colony_location <- data.frame(Lon = 20, Lat = 20)
#' cdt <- generate_env_layer(grid = create_grid(), n = 1, seed = 25)
#'  
#' # launch a travel for a duration of 12h
#' single_traj <- simulate_trajectory_CPF(initial_position = colony_location, 
#'                     resource_layer = cdt$rasters, 
#'                     starting_hour = ymd_hms("2022-08-02 06:00:00"), 
#'                     starting_bearing = c(90,10), 
#'                     starting_step = c(4.5, 3),
#'                     travel_bearing = c(0, 20), 
#'                     travel_step = c(3, 3), 
#'                     foraging_bearing = c(0, 0.5), 
#'                     foraging_step = c(1, 3),
#'                     minx = 0, maxx = 90, 
#'                     miny = 0, maxy = 90,
#'                     max_dist = 40,
#'                     step_duration = 5,
#'                     activity_threshold = 0.70,
#'                     max_duration = 720,
#'                     residence_radius = 2,
#'                     residence_time = 20)
#'
#' # view the trajectory
#' ggplot(single_traj) +
#'   geom_spatraster(data = cdt$rasters, alpha = 0.5) + 
#'   geom_point(aes(x = Lon, y = Lat, color = activity)) +
#'   geom_point(data = colony_location, aes(x = Lon, y = Lat), col = "red") +
#'   scale_fill_viridis(option = "H") 
#'
#' # look at the density distribution of distance to colony and movement parameters
#' ggplot(single_traj) + geom_density(aes(x = dist_col))
#' ggplot(single_traj |> subset(activity %in% c("forage", "travel"))) + 
#'   geom_density(aes(x = angle)) + facet_wrap("activity")
#' ggplot(single_traj |> subset(activity %in% c("forage", "travel"))) + 
#'   geom_density(aes(x = step)) + facet_wrap("activity")
#'
simulate_trajectory_CPF <- function(initial_position, 
                                resource_layer, 
                       starting_hour,
                       starting_bearing = c(90,10),
                       starting_step = c(4.5, 3),
                       travel_bearing = c(0, 20), # (mu, kappa) -> higher kappa = higher concentration
                       travel_step = c(3, 3), #  (scale, rate) -> smaller the rate, higher the dispersion
                       foraging_bearing = c(0, 0.5), 
                       foraging_step = c(1, 3), 
                       minx = 0, maxx = 90, 
                       miny = 0, maxy = 90,
                       max_dist = 40,
                       step_duration = 1,
                       activity_threshold = 0.5,
                       max_duration = 720,
                       residence_radius = NULL,
                       residence_time = NULL) 
{
  if(isFALSE(initial_position$Lon >= minx & initial_position$Lon <= maxx &
         initial_position$Lat >= miny & initial_position$Lat <= maxy)){
    stop("initial_position must be included in the bounding box given by minx, maxx, miny and maxy")
  }
  ext_coord <- as.vector(terra::ext(resource_layer))
  if(isFALSE(initial_position$Lon >= ext_coord[[1]] & initial_position$Lon <= ext_coord[[2]] &
            initial_position$Lat >= ext_coord[[3]] & initial_position$Lat <= ext_coord[[4]])){
    stop("initial_position must be included in the resource_layer extent")
  }
  if(nrow(initial_position) != 1){
    stop("initial_position must include a single row")
  }
  # check sur structure de initial_position sont fait dans potential_position_func()
  
  track_output <- data.frame(Lon = initial_position$Lon,
                             Lat = initial_position$Lat,
                             angle = NA,
                             step = 0,
                             env = NA,
                             dist_col = 0,
                             activity = "start",
                             stepID = 0,
                             ymd_hms = starting_hour,
                             x_from = initial_position$Lon,
                             y_from = initial_position$Lat,
                             date_from = starting_hour)
  
  ### Departs from the colony - outbound phase of travel and foraging bouts
  i <- 2
  while(
      track_output[i-1, "dist_col"] < max_dist &
      track_output[i-1, "ymd_hms"] < ymd_hms(starting_hour) + lubridate::minutes(max_duration)
  ){
    # starts with the initial bearing
    if(i == 2){ 
      potential_position <- NULL
      while(is.null(nrow(potential_position))) { # if no points possible then do it again
        potential_position <- potential_position_func(n = 10, 
                                                      bearing = starting_bearing, 
                                                      step = starting_step, 
                                                      from = track_output[i - 1, ],
                                                      colony_location = initial_position, 
                                                      resource_layer = resource_layer) |>
          subset(Lon < maxx & Lon > minx) |>
          subset(Lat < maxy & Lat > miny) |>
          dplyr::slice_sample(n = 1)
      } 
      track_output[i, c("Lon","Lat","angle","step","env","dist_col")] <- potential_position[, c("Lon","Lat","angle","step","env","dist_col")]
      track_output[i, "stepID"] <-  track_output[i-1, "stepID"] + 1
      track_output[i, "ymd_hms"] <-  track_output[i-1, "ymd_hms"] + lubridate::minutes(step_duration)
      track_output[i, "x_from"] <-  track_output[i-1, "Lon"]
      track_output[i, "y_from"] <-  track_output[i-1, "Lat"]
      track_output[i, "date_from"] <-  track_output[i-1, "ymd_hms"]
      track_output[i, "activity"] <- "travel"
    }
    # continue with traveling parameters but not yet condition on environment
    if(i %in% c(3:5)){
      potential_position <- NULL
      while(is.null(nrow(potential_position))) { # if no points possible then do it again
        potential_position <- potential_position_func(n = 10, 
                                                      bearing = travel_bearing, 
                                                      step = travel_step, 
                                                      from = track_output[i - 1, ],
                                                      colony_location = initial_position, 
                                                      resource_layer = resource_layer) |>
          subset(Lon < maxx & Lon > minx) |>
          subset(Lat < maxy & Lat > miny) |>
          dplyr::slice_sample(n = 1) 
      } 
      track_output[i, c("Lon","Lat","angle","step","env","dist_col")] <- potential_position[, c("Lon","Lat","angle","step","env","dist_col")]
      track_output[i, "stepID"] <-  track_output[i-1, "stepID"] + 1
      track_output[i, "ymd_hms"] <-  track_output[i-1, "ymd_hms"] + lubridate::minutes(step_duration)
      track_output[i, "x_from"] <-  track_output[i-1, "Lon"]
      track_output[i, "y_from"] <-  track_output[i-1, "Lat"]
      track_output[i, "date_from"] <-  track_output[i-1, "ymd_hms"]
      track_output[i, "activity"] <- "travel"
    }else{
    ### Starts foraging bouts
      # sample potential positions based on movement type of previous step and select next step based on environment
      if(track_output[i-1, "activity"] == "travel"){

        if(all(isFALSE(is.null(residence_time)), isFALSE(is.null(residence_radius)), isTRUE(i>residence_time))){
          # check for residence time only when both parameters are provided and 
          # when i is largest than the residence time
          buf <- track_output[i-1,] |> 
            sf::st_as_sf(coords = c("Lon", "Lat")) |> 
            sf::st_buffer(dist = residence_radius)
          previous_positions <- track_output[c(i-(residence_time+1), i-2), ] |> 
            sf::st_as_sf(coords = c("Lon", "Lat")) 
          
          if(isTRUE(all(sf::st_within(previous_positions, buf, sparse = F)))){ # if all points during the residence time interval are within the residence radius, then subset the one point farthest from the previous step
            # sample potential points
            potential_position <- NULL
            while(is.null(nrow(potential_position))) { # if table is empty then do it again
              potential_position <- potential_position_func(n = 10, 
                                                            bearing = travel_bearing, 
                                                            step = travel_step, 
                                                            from = track_output[i - 1, ],
                                                            colony_location = initial_position, 
                                                            resource_layer = resource_layer) |>
                  subset(Lon < maxx & Lon > minx) |>
                  subset(Lat < maxy & Lat > miny)
            } 
            # extract the ones outside the residence_radius
            potential_position_sf <- potential_position |> 
              mutate(x = Lon, y = Lat) |> 
              sf::st_as_sf(coords = c("x", "y")) 
            # if all potential position fall within the radius, choose based on distance (farthest from prev point)
            if(isTRUE(all(sf::st_within(potential_position_sf, buf, sparse = F)))){
              potential_position$dist_from_previous <- as.vector(fields::rdist(track_output[i-1, c("Lon", "Lat")], 
                                                                 potential_position[, c("Lon", "Lat")]))
              potential_position <- potential_position |> 
                dplyr::arrange(dplyr::desc(dist_from_previous)) |> 
                dplyr::slice_head(n = 1)
            }else{ # if some are outside, extract it and take the best env value
              potential_position <- potential_position_sf[ !(sf::st_within(potential_position_sf, buf, sparse = F)) , ] |>
              sf::st_drop_geometry()
              potential_position <- potential_position |> 
                dplyr::arrange(dplyr::desc(env)) |> 
                dplyr::slice_head(n = 1)
            }
          } else {
            potential_position <- NULL
            while(is.null(nrow(potential_position))) { # if table is empty then do it again
              potential_position <- potential_position_func(n = 10, 
                                                            bearing = travel_bearing, 
                                                            step = travel_step, 
                                                            from = track_output[i - 1, ],
                                                            colony_location = initial_position, 
                                                            resource_layer = resource_layer) |>
                  subset(Lon < maxx & Lon > minx) |>
                  subset(Lat < maxy & Lat > miny)|>
              dplyr::arrange(dplyr::desc(env)) |> # decreasing according to env values
              dplyr::slice_head(n = 4)
            } 
          potential_position <- potential_position |> dplyr::slice_sample(n = 1)
          }
        } else {
          potential_position <- NULL
          while(is.null(nrow(potential_position))) { # if table is empty then do it again
              potential_position <- potential_position_func(n = 10, 
                                                            bearing = travel_bearing, 
                                                            step = travel_step, 
                                                            from = track_output[i - 1, ],
                                                            colony_location = initial_position, 
                                                            resource_layer = resource_layer) |>
                  subset(Lon < maxx & Lon > minx) |>
                  subset(Lat < maxy & Lat > miny)|>
              dplyr::arrange(dplyr::desc(env)) |> # decreasing according to env values
              dplyr::slice_head(n = 4)
            } 
          potential_position <- potential_position |> dplyr::slice_sample(n = 1)
        }
      }
      if(track_output[i-1, "activity"] == "forage"){
          if(all(isFALSE(is.null(residence_time)), isFALSE(is.null(residence_radius)), isTRUE(i>residence_time))){
          # check for residence time only when both parameters are provided and 
          # when i is largest than the residence time
          buf <- track_output[i-1,] |> 
            sf::st_as_sf(coords = c("Lon", "Lat")) |> 
            sf::st_buffer(dist = residence_radius)
          previous_positions <- track_output[c(i-(residence_time+1), i-2), ] |> 
            sf::st_as_sf(coords = c("Lon", "Lat")) 
          
          if(isTRUE(all(sf::st_within(previous_positions, buf, sparse = F)))){ # if all points during the residence time interval are within the residence radius, then subset the one point farthest from the previous step
            # sample potential points
            potential_position <- NULL
            while(is.null(nrow(potential_position))) { # if table is empty then do it again
              potential_position <- potential_position_func(n = 10, 
                                                            bearing = foraging_bearing, 
                                                            step = foraging_step, 
                                                            from = track_output[i - 1, ],
                                                            colony_location = initial_position, 
                                                            resource_layer = resource_layer) |>
                  subset(Lon < maxx & Lon > minx) |>
                  subset(Lat < maxy & Lat > miny)
            } 
            # extract the ones outside the residence_radius
            potential_position_sf <- potential_position |> 
              mutate(x = Lon, y = Lat) |> 
              sf::st_as_sf(coords = c("x", "y")) 
            # if all potential position fall within the radius, choose based on distance (farthest from prev point)
            if(isTRUE(all(sf::st_within(potential_position_sf, buf, sparse = F)))){
              potential_position$dist_from_previous <- as.vector(fields::rdist(track_output[i-1, c("Lon", "Lat")], 
                                                                 potential_position[, c("Lon", "Lat")]))
              potential_position <- potential_position |> 
                dplyr::arrange(dplyr::desc(dist_from_previous)) |> 
                dplyr::slice_head(n = 1)
            }else{ # if some are outside, extract it and take the best env value
              potential_position <- potential_position_sf[ !(sf::st_within(potential_position_sf, buf, sparse = F)) , ] |>
              sf::st_drop_geometry()
              potential_position <- potential_position |> 
                dplyr::arrange(dplyr::desc(env)) |> 
                dplyr::slice_head(n = 1)
            }
          } else {
            potential_position <- NULL
            while(is.null(nrow(potential_position))) { # if table is empty then do it again
              potential_position <- potential_position_func(n = 10, 
                                                            bearing = foraging_bearing, 
                                                            step = foraging_step, 
                                                            from = track_output[i - 1, ],
                                                            colony_location = initial_position, 
                                                            resource_layer = resource_layer) |>
                  subset(Lon < maxx & Lon > minx) |>
                  subset(Lat < maxy & Lat > miny)|>
              dplyr::arrange(dplyr::desc(env)) |> # decreasing according to env values
              dplyr::slice_head(n = 4)
            } 
          potential_position <- potential_position |> dplyr::slice_sample(n = 1)
          }
        } else {
          potential_position <- NULL
          while(is.null(nrow(potential_position))) { # if table is empty then do it again
              potential_position <- potential_position_func(n = 10, 
                                                            bearing = foraging_bearing, 
                                                            step = foraging_step, 
                                                            from = track_output[i - 1, ],
                                                            colony_location = initial_position, 
                                                            resource_layer = resource_layer) |>
                  subset(Lon < maxx & Lon > minx) |>
                  subset(Lat < maxy & Lat > miny)|>
              dplyr::arrange(dplyr::desc(env)) |> # decreasing according to env values
              dplyr::slice_head(n = 4)
            } 
          potential_position <- potential_position |> dplyr::slice_sample(n = 1)
        }
      }
      track_output[i, c("Lon","Lat","angle","step","env","dist_col")] <- potential_position[, c("Lon","Lat","angle","step","env","dist_col")]
      track_output[i, "stepID"] <-  track_output[i-1, "stepID"] + 1
      track_output[i, "ymd_hms"] <-  track_output[i-1, "ymd_hms"] + lubridate::minutes(step_duration)
      track_output[i, "x_from"] <-  track_output[i-1, "Lon"]
      track_output[i, "y_from"] <-  track_output[i-1, "Lat"]
      track_output[i, "date_from"] <-  track_output[i-1, "ymd_hms"]
      # evaluate whether traveling or foraging (if env >= 0.5 = switch) for next step
      track_output[i, "activity"] <- ifelse( potential_position$env >= activity_threshold, "forage", "travel") 
    }
    i = i +1  
    }
  ### Starts homing phase
  i <- nrow(track_output) +1 
  while(track_output[i-1, "dist_col"] >= 0.5 ) {
    # sample potential positions based on movement type of previous step, select next step based on minimum distance to colony
    if(track_output[i-1, "activity"] == "travel"){
      potential_position <- NULL
      while(is.null(nrow(potential_position))) { # if no points possible then do it again 
        potential_position <- potential_position_func(n = 10, 
                                                      bearing = travel_bearing, 
                                                      step = travel_step, 
                                                      from = track_output[i - 1, ],
                                                      colony_location = initial_position, 
                                                      resource_layer = resource_layer) |>
        subset(Lon < maxx & Lon > minx) |>
        subset(Lat < maxy & Lat > miny) |>
        subset(dist_col == min(dist_col))  
        if(nrow(potential_position > 1)) { potential_position <- potential_position[sample(1:nrow(potential_position), 1, replace = F),]  }
      }
    }
    if(track_output[i-1, "activity"] == "forage"){
      potential_position <- NULL
      while(is.null(nrow(potential_position))) {  # if no points possible then do it again
        potential_position <- potential_position_func(n = 10, 
                                                      bearing = foraging_bearing, 
                                                      step = foraging_step, 
                                                      from = track_output[i - 1, ],
                                                      colony_location = initial_position, 
                                                      resource_layer = resource_layer) |>
        subset(Lon < maxx & Lon > minx) |>
        subset(Lat < maxy & Lat > miny) |>
        subset(dist_col == min(dist_col))  
        if(nrow(potential_position > 1)) { potential_position <- potential_position[sample(1:nrow(potential_position), 1, replace = F),]  }
      }
    }
    track_output[i, c("Lon","Lat","angle","step","env","dist_col")] <- potential_position[, c("Lon","Lat","angle","step","env","dist_col")]
      track_output[i, "stepID"] <-  track_output[i-1, "stepID"] + 1
    track_output[i, "ymd_hms"] <-  track_output[i-1, "ymd_hms"] + lubridate::minutes(step_duration)
    track_output[i, "x_from"] <-  track_output[i-1, "Lon"]
    track_output[i, "y_from"] <-  track_output[i-1, "Lat"]
    track_output[i, "date_from"] <-  track_output[i-1, "ymd_hms"]
    track_output[i, "activity"] <- ifelse( potential_position$env >= activity_threshold, "forage", "travel")
    
    i <- i +1
  }
  # add point at colony to end the track
  track_output[i, c("Lon", "Lat")] <- initial_position[, c("Lon", "Lat")]
  track_output[i, "dist_col"] <-  0
  track_output[i, "stepID"] <-  track_output[i-1, "stepID"] + 1
  track_output[i, "ymd_hms"] <-  track_output[i-1, "ymd_hms"] + lubridate::minutes(step_duration)
  track_output[i, "x_from"] <-  track_output[i-1, "Lon"]
  track_output[i, "y_from"] <-  track_output[i-1, "Lat"]
  track_output[i, "date_from"] <-  track_output[i-1, "ymd_hms"]
  track_output[i, "activity"] <- "end"
  return(track_output)
}
# inherits checks for potential_positions
