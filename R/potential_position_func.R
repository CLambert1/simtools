# WARNING - Generated by {fusen} from dev/flat_simulate_mvmt.Rmd: do not edit by hand

#' Identify potential next positions
#'
#' The function generates a bunch of potential positions to chose the next step from. Positions are generated based on provided bearing (Von Mises distribution) and step distributions (gamma distribution). For each position, the value of env_rast is retrieved as well as the distance from the colony location. 
#'
#' @param n Numeric, the number of potential positions to generate
#' @param bearing Numeric vector, mu and kappa to be passed on randomdir
#' @param step  Numeric, shape and rate to be passed on randomdist
#' @param from data.frame including Lon and Lat fields and stepID of the point of origin
#' @param colony_location data.frame vector with lon and lat position of the colony
#' @param resource.layer SpatRaster, the suitability or any resource layer to be used to sort potential position (a single layer)
#' 
#' @importFrom terra extract nlyr
#' @importFrom fields rdist
#' 
#' @return A data.frame with the n potential positions from the point of origin, informed with the value of the provided environmental layer corresponding to each as well as the distance from the colony. 
#' @export
#'
#' @family individual movement functions
#'
#' @examples
#' from <- data.frame(Lon = 1, Lat = 2, toto = 5)
#' colony_location <- data.frame(Lon = 2, Lat = 5)
#' cdt <- generate_env_layer(grid = create_grid(), n = 1)$rasters
#' potential_position_func(n = 10, from = from, 
#'                         colony_location = colony_location, resource_layer = cdt, 
#'                         bearing = c(90,10), step = c(4.5, 3))
potential_position_func <- function(n, bearing, step, from, colony_location, resource_layer){
  if(isTRUE(inherits(resource_layer, "SpatRaster"))){
    if(terra::nlyr(resource_layer) > 1){
      stop("env_layer must include a single layer")
    }
  } else { stop("env_layer must be a SpatRaster") }
  if(isFALSE(inherits(from, "data.frame"))){
    stop("from must be a data.frame")
  } else {
    if(isFALSE(nrow(from) == 1)){
      stop(glue::glue("from must include a single row"))
    } else {
      if(isFALSE(all(c("Lon", "Lat") %in% names(from)))){
      stop(glue::glue("from must include Lon, Lat columns"))
    }}
  }
  if(length(bearing) != 2){
    stop("bearing must be of length 2")
  }
  if(length(step) != 2){
    stop("step must be of length 2")
  }
  df <- data.frame(angle = randomdir(n = n, mu = bearing[1], kappa = bearing[2]),
                   step = randomdist(n = n, shape = step[1], rate = step[2]))      # generate angles in degree
  df$Lon <- from$Lon + (cos(df$angle) * df$step)
  df$Lat <- from$Lat + (sin(df$angle) * df$step)
  df$stepID <- from$stepID
  df$env <- terra::extract(resource_layer, df[, c("Lon","Lat")])[[2]]
  df$dist_col <- as.vector(fields::rdist(colony_location, df[, c("Lon", "Lat")]))
  df$potential_position_id <- 1:n
  return(df)
}

