# WARNING - Generated by {fusen} from dev/flat_simulate_survey.Rmd: do not edit by hand

#' Launch a survey on a population of moving individuals
#'
#' This function identifies the individuals detected during a standardised survey by spatial and temporal matching between segments and movement bouts of individuals. The default behaviour emulates a strip-transect survey, by considering individuals falling within a strip around the surveyed segments to be detected, but line-transect methodology can also be emulated by setting line-transect to TRUE. In this case, the actual detection of individuals is conditioned by their distance to the track line (probability of detection is computed using either half-normal of hazard rate detection functions). 
#' 
#'
#' @param survey_data_buffered sf object, buffered segments as provided by \code{\link{generate_survey_plan}} and processed by \code{\link{assign_flight_plan}}. Matching sightings will be defined as individual movement bouts falling within the buffer around segments, so be careful about the buffer length. 
#' @param survey_data_linear sf object, non-buffered segments (LINESTRING type) as provided by \code{\link{generate_survey_plan}}, used to compute distance to the trac line
#' 
#' @param traj_data data.frame of individual movements, as provided by \code{\link{simulate_trajectory_CPF}} and \code{\link{simulate_trajectory_FR}}
#' @param track_id_col character, the column name storing the individual id in traj_data
#' @param seg_id_col character, the column name storing the segment id in survey_data
#' @param line_transect Boolean. Should the detection process follow line-transect methodology? Default to FALSE (strip-transect setting). If TRUE, sightings are spatially matched (falling inside segment buffers) then a detection probability is calculated based on the distance to the track line. 
#' @param detection_function character, half-normal ("hn") or hasard rate ("hr") detection function, default to "hn"
#' @param sigma numeric, if line_transect is TRUE, defines the effective strip half-width used in detection functions (km)
#' @param b numeric, if detection_function = "hr", b value to be passed on to the detection_hr function
#'
#' @importFrom sf st_linestring st_sfc st_as_sf st_sf st_centroid st_distance st_crosses st_contains st_coordinates st_drop_geometry
#' @importFrom lubridate as.duration interval intersect int_overlaps
#' @importFrom dplyr pull left_join ungroup group_by mutate n summarize
#' @importFrom purrr map
#' @importFrom glue glue
#' @importFrom stats rbinom
#'
#' @return A list included an effort table (the survey_data with the number of individuals sighted per segment "N_ind_tot") and an obs_table (summarising the movement bouts detected by the survey, with their centroid coordinates). If line_transect is TRUE, obs_table includes two supplementary columns describing the probability an individual is detected based on its distance to the track line ("prob_dist") and whether it is detected or not ("detected"), while the effort table includes an additional column ("N_ind_detected") summarising the number of individuals detected based on distance to the track line. 
#' 
#' @export
#' 
#' @family survey simulation functions 
#' @seealso \code{\link{simulate_trajectory_CPF}} \code{\link{simulate_trajectory_FR}}
#' 
#' @examples
#' # an example with a small number of individuals
#' survey <- suppressMessages(launch_survey_on_movement(
#'   survey_data_buffered = example_data$flight_plan,
#'   survey_data_linear = example_data$survey$segments,
#'   traj_data = example_data$mvmt_data,
#'   line_transect = TRUE, detection_function = "hn",
#'   sigma = 0.2
#' ))
#'
#' # look at the number of sightings
#' summary(survey$effort_table$N_ind_tot)
#'
#' plot(sf::st_drop_geometry(survey$obs_table[, c("dist_seg", "prob_dist")]), 
#'      xlab = "distance to the track line", ylab = "detection probability")
#'
#' # all sightings are in a few segments
#' library(ggplot2)
#' ggplot(survey$effort_table) +
#'   geom_sf(data = survey$obs_table, 
#'           aes(shape = as.factor(detected)), size = 2) +
#'   geom_sf(aes(fill = N_ind_tot)) + 
#'   viridis::scale_fill_viridis(limits = c(1,10), 
#'                               na.value = NA, alpha = 0.5)
#'
launch_survey_on_movement <- function(
    survey_data_buffered,
    survey_data_linear,
    traj_data,
    track_id_col = "ind_id",
    seg_id_col = "seg_id",
    line_transect = FALSE, sigma = 0.2, b = 1,
    detection_function = "hn"){
  # check 
  if(isFALSE(all(inherits(survey_data_buffered, "sf"),inherits(survey_data_linear, "sf")))){
    stop("survey_data_buffered and survey_data_linear must be a sf object")
  }
  if(isFALSE(is.data.frame(traj_data)) | isTRUE(inherits(traj_data, "sf"))){
    stop("traj_data must be a data.frame")
  }
  if(isFALSE(all(is.character(track_id_col), is.character(seg_id_col)))){
    stop("track_id_col and seg_id_col must be character")
  }
  
  # function for use later
  st_segment = function(r){sf::st_linestring(t(matrix(unlist(r), 2, 2)))}
  
  # rename columns to be used
  traj_data$track_id <- traj_data |> dplyr::pull(track_id_col)
  survey_data_buffered$seg_id <- survey_data_buffered |> dplyr::pull(seg_id_col)
  survey_data_linear$seg_id <- survey_data_linear |> dplyr::pull(seg_id_col)
  
  # format columns
  traj_data$ymd_hms <- as.POSIXct(traj_data$ymd_hms, tz = "UTC")
  traj_data$date_from <- as.POSIXct(traj_data$date_from, tz = "UTC")
  traj_data$interval <- lubridate::interval(traj_data$date_from, traj_data$ymd_hms)
  
  survey_data_buffered$start_time <- as.POSIXct(survey_data_buffered |> dplyr::pull("start_time"), tz = "UTC")
  survey_data_buffered$end_time <- as.POSIXct(survey_data_buffered |> dplyr::pull("end_time"), tz = "UTC")
  survey_data_buffered$interval <- lubridate::interval(survey_data_buffered$start_time, survey_data_buffered$end_time)
  
  # launch the detection process
  detection_table <- lapply(1:nrow(survey_data_buffered), function(i){
    message(glue::glue("Processing survey segment {i}"))
    
    # subset each segment
    sub_seg <- survey_data_buffered[i,]
    sub_seg$N_ind_tot <- NA
    
    # check which movement bouts overlap the sampling interval
    interval_seg <- sub_seg$interval
    sub_traj <- traj_data[lubridate::int_overlaps(traj_data$interval, interval_seg),]
    
    # if there is matching movement bouts, process detection
    if(nrow(sub_traj) != 0){
      # select only the longer overlap if several matching movement bouts for a single individual
      # and sample the first if several bouts have the same overlap duration for a same individual
      sub_traj$overlap_duration <- lubridate::as.duration(lubridate::intersect(sub_traj$interval, interval_seg))
      sub_traj <- sub_traj|> 
      dplyr::group_by(track_id)  |> 
      dplyr::arrange(dplyr::desc(overlap_duration)) |> 
      dplyr::slice_head(n = 1) |> 
      dplyr::ungroup() 
  
      # transform movement bouts to linestring
      sub_traj$geometry = sf::st_sfc(sapply(1:nrow(sub_traj), 
                            function(i){st_segment(sub_traj[i, c("Lon", "Lat", "x_from", "y_from")])}, simplify = FALSE))
      sub_traj <- sf::st_sf(sub_traj)
      # plot(sf::st_geometry(sub_traj), axes = T) 
      
      # look which movement bouts cross the segment or are included within the segment
      cross_id <- unlist( sf::st_crosses(x = sub_seg, y = sub_traj, sparse = T) )
      within_id <- unlist( sf::st_contains(x = sub_seg, y = sub_traj, sparse = T) )
      det_id <- c(cross_id, within_id)
      
      # sum the number of movement bouts
      if(length(det_id) != 0){
        obs <- data.frame(track_id = sub_traj$track_id[det_id], 
                          step_id = sub_traj$stepID[det_id], 
                          seg_id = sub_seg$seg_id,
                          dist_seg_edge = sub_traj[det_id,] |> suppressWarnings(sf::st_centroid()) |> sf::st_distance(sub_seg),
                          start_time_seg = sub_seg$start_time,
                          end_time_seg = sub_seg$end_time
        )
        obs <- obs |>
          dplyr::mutate(centroid_x = as.vector(suppressWarnings(sf::st_coordinates(sf::st_centroid( sub_traj[det_id,] ))[,"X"])),
                        centroid_y = as.vector(suppressWarnings(sf::st_coordinates(sf::st_centroid( sub_traj[det_id,] ))[,"Y"])) )
        obs <- obs |> subset(dist_seg_edge == 0) # remove movement bouts whose centroid is not included in the seg (= too far from the transect line)
        sub_seg$N_ind_tot <- nrow( obs[!duplicated(obs),] )
      } else {
        sub_seg$N_ind_tot <- 0
        obs <- NULL
      }
    } else {
      sub_seg$N_ind_tot <- 0
      obs <- NULL
    }
    
    return(list(survey = sub_seg, obs_table = obs))
  })
  
  # extract effort table
  survey <- detection_table |> purrr::map(`[[`, 1) |> do.call(what = "rbind")
  survey <- survey |> 
    dplyr::mutate(centre_x = as.vector(suppressWarnings(sf::st_coordinates(sf::st_centroid(survey))[,"X"])),
           centre_y = as.vector(suppressWarnings(sf::st_coordinates(sf::st_centroid(survey))[,"Y"])))
  
  obs_table <- detection_table |> purrr::map(`[[`, 2) |> do.call(what = "rbind") |>
    dplyr::mutate(Lon = centroid_x, Lat = centroid_y) |>
    sf::st_as_sf(coords = c("centroid_x", "centroid_y"))  
  
  
  if(line_transect == TRUE){
    message("Applying detection function")
    # compute distance to the track line and line-transect setting
    obs_table$dist_seg <- lapply(1:nrow(obs_table), function(i){
      sub_seg <- survey_data_linear |> subset(seg_id == obs_table[i, ] |> dplyr::pull("seg_id"))
      dist <- sf::st_distance(sub_seg, obs_table[i,])
      return(dist)
    }) |> unlist()
   
  
    # define the detection probability based on distance to the track line
    if(detection_function == "hn"){
      obs_table$prob_dist <- detfunc_hn(x = obs_table$dist_seg, sigma = sigma)  
    }
    if(detection_function == "hr"){
      obs_table$prob_dist <- detfunc_hr(x = obs_table$dist_seg, sigma = sigma, b = b)  
    }
    
    # compute if detected
    obs_table$detected <- rbinom(nrow(obs_table), 1, obs_table$prob_dist) 

    # count the number of detection per seg
    count_data <- obs_table |> sf::st_drop_geometry() |> subset(detected == 1) |> dplyr::group_by(seg_id) |> dplyr::summarise(N_ind_detected = dplyr::n())

    # add to the survey dataframe
    survey <- dplyr::left_join(survey, count_data, by = "seg_id")
    survey$N_ind_detected[is.na(survey$N_ind_detected)] <- 0
  }

      
  # export
  return(list(effort_table = survey, obs_table = obs_table))
}
