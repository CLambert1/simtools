# WARNING - Generated by {fusen} from dev/flat_simulate_survey.Rmd: do not edit by hand

#' Generate a transect survey design
#'
#' This function builds a simple transect design layout, consisting of parallel transects covering a given area in the virtual environment, spaced out by a given distance. The layout can either be horizontal (the default) or vertical. The transects can be segmentized to a given length, and transects or segments can be buffered.
#'
#' @param bbx_xmin,bbx_xmax,bbx_ymin,bbx_ymax numeric. Limits of the bounding box the transects will be generated in
#' @param start_x,end_x numeric. Start and end x coordinates of the transects
#' @param start_y,end_y numeric. Start and end y coordinates of the transects
#' @param space_out_factor numeric. Number of space units between transects
#' @param type character. Either "horizontal" (the default) or "vertical
#' @param segmentize Boolean. If TRUE, the transects are cut in smaller segments. Default to FALSE.
#' @param merge_last_seg Boolean. Should the last segment of a transect be merged with the previous one? Default to FALSE
#' @param seg_length numeric. Segment length.
#' @param buffer Boolean. Should a buffer be drawn around transects or segments? If segmentize is TRUE, buffers are drawn around segments, if segmentize is FALSE, they are drawn around transects. 
#' @param buffer_width numeric. Width of the buffer on each side of the segments or transects. 
#'
#' @importFrom raster spLines extent
#' @importFrom sf st_as_sf st_cast as_Spatial st_length, st_buffer
#' @importFrom qdapTools id
#' @importFrom purrr reduce
#' @importFrom magrittr %>%
#'
#' @return A named list. 
#' @export
#'
#' @examples
#' surv <- generate_survey_plan(bbx_xmin = 5, bbx_xmax = 85, bbx_ymin = 5, bbx_ymax = 85,
#'                              start_x = 10, end_x = 80, start_y = 10, end_y = 80,
#'                              space_out_factor = 4, segmentize = TRUE, seg_length = 2, 
#'                              buffer = TRUE, buffer_width = 0.2
#'                              )
#' par(mfrow = c(2,2), mar = c(2.5,2.5,4,0.5))
#' raster::plot(surv$bbx, axes = T, main = "bounding box")
#' plot(sf::st_geometry(surv$transects), axes = T, main = "transects")
#' plot(sf::st_geometry(surv$segments), axes = T, main = "segments")
#' plot(sf::st_geometry(surv$buffered_segments), axes = T, main = "buffered seg")
generate_survey_plan <- function(bbx_xmin, bbx_xmax, bbx_ymin, bbx_ymax,
                                 start_x, end_x, start_y, end_y, space_out_factor,
                                 type = "horizontal", 
                                 segmentize = FALSE, merge_last_seg = FALSE, seg_length,
                                 buffer = FALSE, buffer_width){
  # check
  if(isFALSE(type %in% c("horizontal", "vertical"))){
    stop("type must either be horizontal or vertical")
  }
  if(isFALSE(all(is.numeric(bbx_xmin), is.numeric(bbx_xmax), is.numeric(bbx_ymin), is.numeric(bbx_ymax),
                 is.numeric(start_x), is.numeric(end_x), is.numeric(start_y), is.numeric(end_y),
                 is.numeric(space_out_factor)))){
    stop("bbx_xmin, bbx_xmax, bbx_ymin, bbx_ymax, start_x, end_x, start_y, end_y, space_out_factor must all be numeric")
  }
  if(isFALSE(is.logical(segmentize))){
    stop("segmentize must be Boolean")
  } 
  if(isTRUE(segmentize)){
    if(isFALSE(is.logical(merge_last_seg))){
      stop("merge_last_seg must be Boolean")
    }
    
    if(isTRUE(is.null(seg_length))){
      stop("seg_length must be provided if segmentize is TRUE")
    } else {
      if(isFALSE(is.numeric(seg_length))){
        stop("seg_length must be numeric")
      }
    }
  }
  if(isFALSE(is.logical(buffer))){
    stop("buffer must be Boolean")
  }
  if(isTRUE(buffer)){
    if(isTRUE(is.null(buffer_width))){
      stop("buffer_width must be provided if buffer is TRUE")
    } else {
      if(isFALSE(is.numeric(buffer_width))){
        stop("buffer_width must be numeric")
      }
    }
  }
  
  # define bounding box
  bbx <- as(raster::extent(c(bbx_xmin,bbx_xmax,bbx_ymin,bbx_ymax)), "SpatialPolygons")
  
  # create transects
  if(type == "horizontal"){
    vect_y <- seq(start_y, end_y, by = space_out_factor) 
    list_coord <- lapply(seq_along(vect_y), function(i) { rbind( c(start_x, vect_y[i]), c(end_x, vect_y[i])) })
    transects <- raster::spLines(list_coord) |> sf::st_as_sf() |> sf::st_cast(to = "LINESTRING") |>
        dplyr::mutate(length = (end_x - start_x))
    transects$id <- 1:nrow(transects)
  }
  if(type == "vertical"){
    vect_x <- seq(start_x, end_x, by = space_out_factor) 
    list_coord <- lapply(seq_along(vect_x), function(i) { rbind( c(vect_x[i], start_y), c(vect_x[i], end_y)) })
    transects <- raster::spLines(list_coord) |> sf::st_as_sf() |> sf::st_cast(to = "LINESTRING") |>
        dplyr::mutate(length = (end_y - start_y))
    transects$id <- 1:nrow(transects)
  }

  if(segmentize == TRUE){
    idTransects <- unique(transects$id)
    seg <- lapply(1:length(idTransects), function(i){
      trans <- transects |> sf::st_as_sf() |> subset(id == idTransects[i]) |>
          sf::as_Spatial()
      seg <- SegmentSpatialLines(trans, length = seg_length, merge.last = merge_last_seg) %>%
        sf::st_as_sf(seg) %>%
          dplyr::mutate(transect = trans$id,
              TransLengthKm = as.numeric(round(trans$length,0)),
              SegLengthKm = as.numeric(round(sf::st_length(.),0)),
              seg_id = qdapTools::id(x = ., prefix = paste(trans$id, "_Seg_", sep ="")))
  
      return(seg)
      }) |> purrr::reduce(sf:::rbind.sf) # |> suppressWarnings(mapedit:::combine_list_of_sf(.))
    
    if(buffer == TRUE){
      buf <- seg |> sf::st_as_sf() |> sf::st_buffer(dist = buffer_width, endCapStyle = "FLAT")
      return(list(transects = transects, segments = seg, buffered_segments = buf, bbx = bbx))
    } else{
      return(list(transects = transects, segments = seg, bbx = bbx))
    }
  } else {
    if(buffer == TRUE){
      buf <- transects |> sf::st_as_sf() |> sf::st_buffer(dist = buffer_width, endCapStyle = "FLAT")
      return(list(transects = transects, buffered_transects = buf, bbx = bbx))
    } else {
       return(list(transects = transects, bbx = bbx))
    }    
  }
}
