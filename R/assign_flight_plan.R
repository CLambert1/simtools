# WARNING - Generated by {fusen} from dev/flat_simulate_survey.Rmd: do not edit by hand

#' Assign a flight plan to a survey design
#'
#' @param sf_segments sf object, segments to assign flight plan to
#' @param flight_id numeric vector, giving the order by which the segments must be surveyed
#' @param col_trans_id character, the column in sf_segments storing transect names
#' @param flight_day character, the day the survey flight is carried out (ymd format: "2022-02-08")
#' @param survey_start_hour character, the hour the survey is started (hms format: "06:00:00")
#' @param flight_speed numeric, the speed at which a single segment is surveyed (in km/h)
#' @param intertransect_gap_duration numeric, the duration of the transit from a transect to the other (in seconds)
#'
#' @importFrom sf st_geometry_type st_drop_geometry
#' @importFrom dplyr pull arrange
#' @importFrom lubridate ymd_hms seconds
#'
#' @return a sf table with four additional columns (transect_id, flight_id, start_time and end_time) informing the period over which each segment is surveyed
#' @export
#'
#' @examples
#' surv <- generate_survey_plan(bbx_xmin = 5, bbx_xmax = 85, bbx_ymin = 5, bbx_ymax = 85,
#'                              start_x = 5, end_x = 85, start_y = 5, end_y = 85,
#'                              space_out_factor = 4, segmentize = TRUE, seg_length = 1, 
#'                              buffer = TRUE, buffer_width = 0.2
#'                              )
#'
#' # Here, set up a flight plan where the first transect is flown in a given 
#' # direction, the second in the other direction etc, so that the aircraft 
#' # does not need to go all the way to the other side of the survey area 
#' # to start a new transect. The intransect.gap.duration is thus set to 1 minute, 
#' # a the flight speed to 160 km/h (the classical speed for aerial surveys). 
#' # in that case, the survey duration for a single segment is 22.5 seconds. 
#' flight_id <- c(1:80, 160:81, 161:240, 320:241, 321:400, 480:401, 481:560, 640:561, 641:720, 800:721, 801:880, 960:881, 961:1040,
#'                    1120:1041, 1121:1200, 1280:1201, 1281:1360, 1440:1361, 1441:1520, 1600:1521, 1601:1680)
#'
#' # assign the time periods to each segment
#' flight_plan <- assign_flight_plan(
#'     sf_segments = surv$buffered_segments,
#'     flight_id = flight_id,
#'     col_trans_id = "transect",
#'     flight_day = "2022-02-08", 
#'     survey_start_hour = "06:00:00",
#'     flight_speed = 160,
#'     intertransect_gap_duration = 60
#' )
#'
#' # plot to check everything is ok
#' library(ggplot2)
#' ggplot(flight_plan) +
#'     geom_sf(aes(fill = start_time),
#'             color = "black", size = 0.2) +
#'     scale_fill_datetime(low = "#8073ac", high = "#fdb863") +
#'     theme_bw() + theme(panel.grid = element_blank()) +
#'     labs(fill = "Hour", limits = c("06:00", "16:16"), x = "x", y = "y")+
#'     coord_sf(xlim = c(0,90), ylim = c(0,90))
#'
#' ggplot(flight_plan) +
#'     geom_sf(aes(fill = flight_id),
#'             color = "black", size = 0.2)
assign_flight_plan <- function(
    sf_segments,
    flight_id,
    col_trans_id,
    flight_day, 
    survey_start_hour,
    flight_speed,
    intertransect_gap_duration
){
  # checks
  if(isFALSE( inherits(sf_segments, "sf") )){
    stop("sf_segments must be a sf object")
  }
  if(isFALSE( length(unique(sf::st_geometry_type(sf_segments))) == 1) ){
    stop("sf_segments must include only one geometry type (POLYGON")
  }
  if(isFALSE( unique(sf::st_geometry_type(sf_segments)) == "POLYGON")){
    stop("sf_segments geometry is not of type POLYGON")
  }
  if(isFALSE( length(flight_id) == nrow(sf_segments) )){
    stop("flight_id must be of the same length as sf_segments")
  }
  if(isFALSE( all( is.character(flight_day), is.character(survey_start_hour), is.character(col_trans_id) ) )){
    stop("flight_day, survey_start_hour and col_trans_id must be character")
  }
  if(isFALSE( all( is.numeric(flight_speed), is.numeric(intertransect_gap_duration) ) )){
    stop("flight_speed and intertransect_gap_duration must be numeric")
  }
  if(isFALSE( col_trans_id %in% names(sf_segments) )){
    stop("col_trans_id must be a column of sf_segments")
  }
  
  # function
  seg <- sf_segments
  seg$transect_id <- seg |> dplyr::pull(col_trans_id)
  seg$flight_id <- flight_id
  
  seg_ord <- seg |> dplyr::arrange(flight_id)
  
  # compute date time for all segments iteratively, following the flight order
  for(i in 1:length(flight_id)){
    if(i == 1) {
      seg_i <- seg_ord |> subset(flight_id == i) |> sf::st_drop_geometry()
      # if first seg of the first transect, start time is the starting time of the full survey. The duration of a seg is retrieved from the seg length and the survey speed, from which endtime is computed
      starttime <- lubridate::ymd_hms(paste(flight_day, survey_start_hour, sep = " "))
      seg_duration <- (seg_i[, "SegLengthKm"]/flight_speed)*60*60
      endtime <- starttime + lubridate::seconds(seg_duration)
      
      seg_ord[which(seg_ord$flight_id == i), "start_time"] <- starttime
      seg_ord[which(seg_ord$flight_id == i), "end_time"] <- endtime
    } 
    if(i != 1){
      seg_i <- seg_ord |> subset(flight_id == i) |> sf::st_drop_geometry()
      prev_seg <- seg_ord |> subset(flight_id == i-1) |> sf::st_drop_geometry()
      
      if( seg_i[, "transect_id"] != prev_seg[, "transect_id"] ){
        # if a new transect is started, the delay between the current segment and the previous is set to intransect.gap.duration
        starttime <- prev_seg[, "end_time"] + lubridate::seconds(intertransect_gap_duration)
        seg_duration <- (seg_i[, "SegLengthKm"]/flight_speed)*60*60
        endtime <- starttime + lubridate::seconds(seg_duration)
        
        seg_ord[which(seg_ord$flight_id == i), "start_time"] <- starttime
        seg_ord[which(seg_ord$flight_id == i), "end_time"] <- endtime
      } else {
        # otherwise, starttime is computed as the endtime of the previous seg + half a second (to avoid overlap)
        starttime <- prev_seg[, "end_time"] + lubridate::seconds(0.5)
        seg_duration <- (seg_i[, "SegLengthKm"]/flight_speed)*60*60
        endtime <- starttime + lubridate::seconds(seg_duration)
        
        seg_ord[which(seg_ord$flight_id == i), "start_time"] <- starttime
        seg_ord[which(seg_ord$flight_id == i), "end_time"] <- endtime
      }
    }
  }
  return(seg_ord)
}
