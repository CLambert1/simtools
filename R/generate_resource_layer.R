# WARNING - Generated by {fusen} from dev/flat_simulate_env.Rmd: do not edit by hand

#' Resource selection function
#'
#' @param beta The beta values to multiply the environmental layers with (must be as much beta as layers)
#' @param env_layers Environmental layers to build the resource from. Can either be a data frame (including map coordinates and environmental layer values) or a SpatRast. 
#' @param coordinate_fields If env_layers is a data frame, the fields corresponding to the map coordinates (e.g. c("x", "y"), the default)
#' @param norm Should the resource layer be normalized? 
#' @param return_rasters Should the function returns the resource as SpatRast in addition to the data frame?

#' @importFrom dplyr select
#' @importFrom purrr reduce
#' @importFrom terra rast
#' 
#' @return Returns a data frame with the suitability layer, as well as SpatRast is return_rasters = TRUE
#' @export
#'
#' @examples
#' library(terra)
#' # simple example
#' grid <- create_grid()
#' cdt <- generate_env_layer(grid = grid)
#' rsce <- generate_resource_layer(env_layers = cdt$rasters,
#'                             beta = c(2, -1.5))
#' str(rsce)
#' plot(rsce$rasters)
#'
#' # also works when coordinates are not names x,y
#' cdt2 <- generate_env_layer(grid = grid, n = 3)$dataframe |> dplyr::rename(lon = x, lat = y)
#' str(generate_resource_layer(env_layers = cdt2, coordinate_fields = c("lon", "lat"),
#'                             beta = c(2, -1.5, 3)) )
generate_resource_layer <- function(beta, env_layers, coordinate_fields = c("x", "y"), norm = TRUE, return_rasters = TRUE){
  # check input format
  if(class(env_layers) %!in% c("SpatRaster", "data.frame")){
    stop("env_layers must be of class SpatRast or data.frame")
  }
  ##### Better TRY INHERITS OR IS()
  
  # convert the env_layers into a dataframe if a raster is provided, use as is otherwise
  if(inherits(env_layers, "data.frame")){
    xy <- env_layers[, coordinate_fields]
    env_cdts <- env_layers |> dplyr::select(!(dplyr::all_of(coordinate_fields))) }  
  
  if(inherits(env_layers, "SpatRaster")){
    xy <- as.data.frame(env_layers, xy = T)[, c("x", "y")]
    env_cdts <- as.data.frame(env_layers) }
  
  # check beta provides as much values as there is layers in env_layers
  if(isFALSE(length(beta) == ncol(env_cdts))) {
    stop("There must be as much beta parameters than env_layers to be used to generate the resource layer.")
  }
  
  # compute the resource layer from the conditions and beta parameters
  suitability <- lapply(1:ncol(env_cdts), function(i){
    env_cdts[,i]*beta[i]
  })  |> purrr::reduce(`+`) 
  # same but farr longer: rsce |> dplyr::rowwise() |> dplyr::mutate(Suitability = sum(dplyr::c_across(dplyr::contains("sim"))))
  
  resource_layer <- cbind(xy, suitability)
    
  # normalize the result or not?
  if(norm == TRUE){
    resource_layer$suitability <- normalize(resource_layer$suitability)
    
    if(return_rasters == TRUE){
      rsce_rast <- terra::rast(x = resource_layer, type = "xyz")
      
      return(list(dataframe = resource_layer, rasters = rsce_rast))
    } else {
      return(resource_layer)
    }
  } else {
    if(return_rasters == TRUE){
      rsce_rast <- terra::rast(x = resource_layer, type = "xyz")
      
      return(list(dataframe = resource_layer, rasters = rsce_rast))
    } else {
      
      return(resource_layer)
    }
  }
}
