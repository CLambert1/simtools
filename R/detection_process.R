# WARNING - Generated by {fusen} from dev/flat_simulate_survey.Rmd: do not edit by hand

#' Detection process on spatial point process
#'
#' This function can be used to simulate the detection process when the surveyed individuals are fixed on the geographical space, for example when the species distribution is generated by \code{\link{simul_spat}}. If strip_transect is emulated, an individual is considered detected if its distance to the track line is lower than the width (provided with sigma). If line-transect is emulated, a half-normal detection function is built using the given sigma as effective strip half-width. The user must define if the simulation is done in a virtual space or not (if not, the distances must be provided in km and pts and transects objects must be projected). 
#'
#' @param pts sf object (points), the position of individuals to be surveyed
#' @param transects sf object (lines), survey layout with transects or segments (not buffered)
#' @param strip_transect Boolean. Should strip-transect methodology be used? Default to TRUE
#' @param sigma numeric, is strip_transect is TRUE, the width of the strip width; if strip-transect is FALSE, the effective strip half-width (in km, if in real space)
#' @param seg_id_col character, the name of the column in transects where the ids are stored
#' @param virtual_space Boolean. Is the survey done in a virtual space? Default to TRUE. 
#'
#' @importFrom sf st_distance st_drop_geometry
#' @importFrom glue glue
#' @importFrom stats rbinom dnorm pnorm
#' @importFrom methods as
#'
#' @return the pts dataframe (sf object) with additional columns: distance, distance_km (if in real space), seg_id (the closest transect or segment from the individual) and detected (1 if the individual is detected, 0 otherwise)
#' @export
#' @family survey simulation functions 
#' @seealso \code{\link{simul_spat}} \code{\link{generate_survey_plan}}
#' @examples
#'
#' grid <- create_grid()
#' env <- generate_env_layer(grid = grid)
#' sp <- suppressWarnings(simul_spat(ref_map = env$rasters$sim1,
#'                  N = 1000, 
#'                  n_sim = 1, 
#'                  return_wgs_coordinates = FALSE))
#'
#' pts <- detection_process(pts = sp, 
#'                          transects = example_data$survey$segments, 
#'                          strip_transect = TRUE, 
#'                          sigma = 0.2, 
#'                          virtual_space = TRUE,
#'                          seg_id_col = "seg_id")
#' plot(sp$x, sp$y)
#' plot(sf::st_geometry(example_data$survey$segments), col = "red", add = TRUE)
#' points(sf::st_drop_geometry(pts[which(pts$detected == 1), c("x", "y")]), 
#'        pch = 20, col = "blue")
detection_process <- function(pts, 
                              transects, 
                              strip_transect = TRUE,
                              sigma = NULL, 
                              seg_id_col = NULL, 
                              virtual_space = TRUE) {
  if(isFALSE(all(inherits(pts, "sf"), inherits(transects, "sf")))){
    stop("pts and transects must be sf objects")
  }
  if(isFALSE(length(unique(sf::st_geometry_type(pts))) == 1)){
    stop("pts must include only one geometry type (POINT)")
  }
  if(isFALSE(unique(sf::st_geometry_type(pts)) == "POINT")){
    stop("pts geometry is not of type POINT")
  }
  if(isFALSE(length(unique(sf::st_geometry_type(transects))) == 1)){
    stop("transects must include only one geometry type (LINESTRING)")
  }
  if(isFALSE(unique(sf::st_geometry_type(transects)) == "LINESTRING")){
    stop("transects geometry is not of type LINESTRING")
  }
  if(isTRUE(is.null(seg_id_col))){
    stop("seg_id_col must be provided")
  } else {
    transects$seg_id <- sf::st_drop_geometry(transects[,seg_id_col]) |> unlist()  
  }
  if(isFALSE(is.numeric(sigma))){
    stop("sigma must be numeric")
  }
  
  ## compute distance with st_distance
  if(isTRUE(virtual_space)){
    dist_mat <- sf::st_distance(
                  x = pts,
                  y = transects)
    pts$distance <- apply(dist_mat, 1, min)
    pts$closest_seg <- apply(dist_mat, 1, function(x) min(which(x == min(x, na.rm = TRUE))))
    pts$seg_id <- transects$seg_id[pts$closest_seg]  
    
    ## detection process
    if(isTRUE(strip_transect)) {
      message(glue::glue("Strip-transect is used with a width of {sigma}"))
      esw <- sigma
      pts$detected <- ifelse(pts$distance <= esw, 1, 0)
    } else {
      message(glue::glue("Line-transect is used with a effective half width of {sigma}"))
      # esw <- (pnorm(+Inf, 0, sigma) - 0.5) / dnorm(0, 0, sigma)
      proba <- exp(- (pts$distance)^2 / (2 * sigma * sigma))
      pts$detected <- stats::rbinom(nrow(pts), size = 1, prob = proba)
    }
    return(pts)
  } else {
    dist_mat <- sf::st_distance(
                  x = pts,
                  y = transects)
    pts$distance <- apply(dist_mat, 1, min)
    pts$distance_km <- pts$distance / 1e3
    pts$closest.seg <- apply(dist_mat, 1, function(x) min(which(x == min(x, na.rm = TRUE))))
    pts$seg_id <- transects$seg_id[pts$closest.seg]
    
    ## detection process
    if(isTRUE(strip_transect)) {
      message(glue::glue("Strip-transect is used with a width of {sigma}"))
      esw <- sigma
      pts$detected <- ifelse(pts$distance_km <= esw, 1, 0)
    } else {
      message(glue::glue("Line-transect is used with a effective half width of {sigma}"))
      esw <- (stats::pnorm(+Inf, 0, sigma) - 0.5) / dnorm(0, 0, sigma)
      proba <- exp(- (pts$distance_km)^2 / (2 * sigma * sigma))
      pts$detected <- stats::rbinom(nrow(pts), size = 1, prob = proba)
    }
    return(pts)
  }
}
