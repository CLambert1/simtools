---
title: "flat_flat_simulate_survey.Rmd empty"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r development, include=FALSE}
library(testthat)

grid <- create_grid()
env <- generate_env_layer(grid = grid)
sp <- simul_spat(ref_map = env$rasters$sim1,N = 1000, n_sim = 1, return_wgs_coordinates = F)

surv <- generate_survey_plan(bbx.xmin = 5, bbx.xmax = 85, bbx.ymin = 5, bbx.ymax = 85,
                             start.x = 5, end.x = 85, start.y = 5, end.y = 85,
                             space.out.factor = 4, segmentize = TRUE, seg.length = 1, 
                             buffer = TRUE, buffer.width = 0.2
                             )

```

```{r development-load}
# Load already included functions if relevant
pkgload::load_all(export_all = FALSE)
```
    
```{r function-segmentize}
### Segmentize transects
### Author : Auriane Virgili (auriane.virgili@univ-lr.fr)

CreateSegment <- function(coords, from, to) {
  distance <- 0
  coordsOut <- c()
  biggerThanFrom <- F
  for (i in 1:(nrow(coords) - 1)) {
    d <- sqrt((coords[i, 1] - coords[i + 1, 1])^2 + (coords[i, 2] - coords[i + 1, 2])^2)
    distance <- distance + d
    if (!biggerThanFrom && (distance > from)) {
      w <- 1 - (distance - from)/d
      x <- coords[i, 1] + w * (coords[i + 1, 1] - coords[i, 1])
      y <- coords[i, 2] + w * (coords[i + 1, 2] - coords[i, 2])
      coordsOut <- rbind(coordsOut, c(x, y))
      biggerThanFrom <- T
    }
    if (biggerThanFrom) {
      if (distance > to) {
        w <- 1 - (distance - to)/d
        x <- coords[i, 1] + w * (coords[i + 1, 1] - coords[i, 1])
        y <- coords[i, 2] + w * (coords[i + 1, 2] - coords[i, 2])
        coordsOut <- rbind(coordsOut, c(x, y))
        break
      }
      coordsOut <- rbind(coordsOut, c(coords[i + 1, 1], coords[i + 1, 2]))
    }
  }
  return(coordsOut)
}

CreateSegments <- function(coords, length = 0, n.parts = 0) {
  stopifnot((length > 0 || n.parts > 0))
  # calculate total length line
  total_length <- 0
  for (i in 1:(nrow(coords) - 1)) {
    d <- sqrt((coords[i, 1] - coords[i + 1, 1])^2 + (coords[i, 2] - coords[i + 1, 2])^2)
    total_length <- total_length + d
  }
  
  # calculate stationing of segments
  if (length > 0) {
    stationing <- c(seq(from = 0, to = total_length, by = length), total_length)
  } else {
    stationing <- c(seq(from = 0, to = total_length, length.out = n.parts), 
                    total_length)
  }
  
  # calculate segments and store the in list
  newlines <- list()
  for (i in 1:(length(stationing) - 1)) {
    newlines[[i]] <- CreateSegment(coords, stationing[i], stationing[i + 1])
  }
  return(newlines)
}

MergeLast <- function(lst) {
  l <- length(lst)
  lst[[l - 1]] <- rbind(lst[[l - 1]], lst[[l]])
  lst <- lst[1:(l - 1)]
  return(lst)
}

#' Title
#'
#' @param sl a spatial line object
#' @param length length to segmentize
#' @param n.parts number of parts to cut the transect into
#' @param merge.last should the last bit be merged with the previous one?
#'
#' @importFrom sp Lines
#' @importFrom sp Line
#' @importFrom sp SpatialLines
#'
#' @return
#'
SegmentSpatialLines <- function(sl, length = 0, n.parts = 0, merge.last = FALSE) {
  stopifnot((length > 0 || n.parts > 0))
  id <- 0
  newlines <- list()
  sl <- as(sl, "SpatialLines")
  for (lines in sl@lines) {
    for (line in lines@Lines) {
      crds <- line@coords
      # create segments
      segments <- CreateSegments(coords = crds, length, n.parts)
      if (merge.last && length(segments) > 1) {
        # in case there is only one segment, merging would result into error
        segments <- MergeLast(segments)
      }
      # transform segments to lineslist for SpatialLines object
      for (segment in segments) {
        newlines <- c(newlines, sp::Lines(list(sp::Line(unlist(segment))), ID = as.character(id)))
        id <- id + 1
      }
    }
  }
  return(sp::SpatialLines(newlines))
}

#' Title
#'
#' @param segments a sf object
#'
#' @importFrom sf st_length
#' @importFrom sf st_union
#' 
#' @return a sf object
#'
Merge <- function(segments) {
  
  n <- as.numeric(nrow(segments))
  
  if (n > 2 && as.numeric(sf::st_length(segments$geometry[n])) < 3000){
    
    corr <- segments[(n-1):n,] %>% summarize(geometry = sf::st_union(geometry)) 
    
    segments_corr <- rbind(segments[1:(n-2),], corr)
    
    return(segments_corr)
    
  }
  
  else if (n == 2 && as.numeric(sf::st_length(segments$geometry[n])) < 3000){
    
    corr <- segments[(n-1):n,] %>% summarize(geometry = sf::st_union(geometry)) 
    
    segments_corr <- corr
    
    return(segments_corr)
    
  }
  
  else {
    
    return(segments)
  }
  
} 
```
  

# 1. Generate a transect design

This design can be done with the *dssd* package (L Marshall, 2021) when working on real-world examples. 

The functions presented here provide facilities to build a simple layout. The built layout will consist of parallel transects covering a given area in the virtual environment, spaced out by a given distance and segmented by a given length. The layout can either be horizontal (the default) or vertical. The design can be generated in virtual or real space, but in the latter case, be cautious about the units (you should work with projected coordinates). 


```{r function-generate_survey_plan}
#' Generate a transect survey design
#'
#' This function builds a simple transect design layout, consisting of parallel transects covering a given area in the virtual environment, spaced out by a given distance. The layout can either be horizontal (the default) or vertical. The transects can be segmentized to a given length, and transects or segments can be buffered.
#'
#' @param bbx.xmin,bbx.xmax,bbx.ymin,bbx.ymax numeric. Limits of the bounding box the transects will be generated in
#' @param start.x,end.x numeric. Start and end x coordinates of the transects
#' @param start.y,end.y numeric. Start and end y coordinates of the transects
#' @param space.out.factor numeric. Number of space units between transects
#' @param type character. Either "horizontal" (the default) or "vertical
#' @param segmentize Boolean. If TRUE, the transects are cut in smaller segments. Default to FALSE.
#' @param merge.last.seg Boolean. Should the last segment of a transect be merged with the previous one? Default to FALSE
#' @param seg.length numeric. Segment length.
#' @param buffer Boolean. Should a buffer be drawn around transects or segments? If segmentize is TRUE, buffers are drawn around segments, if segmentize is FALSE, they are drawn around transects. 
#' @param buffer.width numeric. Width of the buffer on each side of the segments or transects. 
#'
#' @importFrom raster spLines extent
#' @importFrom sf st_as_sf st_cast as_Spatial st_length, st_buffer
#' @importFrom qdapTools id
#' @importFrom purrr reduce
#' @importFrom magrittr %>%
#'
#' @return A named list. 
#' @export
#'
#' @examples
generate_survey_plan <- function(bbx.xmin, bbx.xmax, bbx.ymin, bbx.ymax,
                                 start.x, end.x, start.y, end.y, space.out.factor,
                                 type = "horizontal", 
                                 segmentize = FALSE, merge.last.seg = FALSE, seg.length,
                                 buffer = FALSE, buffer.width){
  # check
  if(isFALSE(type %in% c("horizontal", "vertical"))){
    stop("type must either be horizontal or vertical")
  }
  if(isFALSE(all(is.numeric(bbx.xmin), is.numeric(bbx.xmax), is.numeric(bbx.ymin), is.numeric(bbx.ymax),
                 is.numeric(start.x), is.numeric(end.x), is.numeric(start.y), is.numeric(end.y),
                 is.numeric(space.out.factor)))){
    stop("bbx.xmin, bbx.xmax, bbx.ymin, bbx.ymax, start.x, end.x, start.y, end.y, space.out.factor must all be numeric")
  }
  if(isFALSE(is.logical(segmentize))){
    stop("segmentize must be Boolean")
  } 
  if(isTRUE(segmentize)){
    if(isFALSE(is.logical(merge.last.seg))){
      stop("merge.last.seg must be Boolean")
    }
    
    if(isTRUE(is.null(seg.length))){
      stop("seg.length must be provided if segmentize is TRUE")
    } else {
      if(isFALSE(is.numeric(seg.length))){
        stop("seg.length must be numeric")
      }
    }
  }
  if(isFALSE(is.logical(buffer))){
    stop("buffer must be Boolean")
  }
  if(isTRUE(buffer)){
    if(isTRUE(is.null(buffer.width))){
      stop("buffer.width must be provided if buffer is TRUE")
    } else {
      if(isFALSE(is.numeric(buffer.width))){
        stop("buffer.width must be numeric")
      }
    }
  }
  
  # define bounding box
  bbx <- as(raster::extent(c(bbx.xmin,bbx.xmax,bbx.ymin,bbx.ymax)), "SpatialPolygons")
  
  # create transects
  if(type == "horizontal"){
    vect.y <- seq(start.y, end.y, by = space.out.factor) 
    list_coord <- lapply(seq_along(vect.y), function(i) { rbind( c(start.x, vect.y[i]), c(end.x, vect.y[i])) })
    transects <- raster::spLines(list_coord) |> sf::st_as_sf() |> sf::st_cast(to = "LINESTRING") |>
        dplyr::mutate(length = (end.x - start.x))
    transects$id <- 1:nrow(transects)
  }
  if(type == "vertical"){
    vect.x <- seq(start.x, end.x, by = space.out.factor) 
    list_coord <- lapply(seq_along(vect.x), function(i) { rbind( c(vect.x[i], start.y), c(vect.x[i], end.y)) })
    transects <- raster::spLines(list_coord) |> sf::st_as_sf() |> sf::st_cast(to = "LINESTRING") |>
        dplyr::mutate(length = (end.y - start.y))
    transects$id <- 1:nrow(transects)
  }

  if(segmentize == TRUE){
    idTransects <- unique(transects$id)
    seg <- lapply(1:length(idTransects), function(i){
      trans <- transects |> sf::st_as_sf() |> subset(id == idTransects[i]) |>
          sf::as_Spatial()
      seg <- SegmentSpatialLines(trans, length = seg.length, merge.last = merge.last.seg) |>
        sf::st_as_sf(seg) %>%
          dplyr::mutate(transect = trans$id,
              TransLengthKm = as.numeric(round(trans$length,0)),
              SegLengthKm = as.numeric(round(sf::st_length(.),0)),
              seg.id = qdapTools::id(x = ., prefix = paste(trans$id, "_Seg_", sep ="")))
  
      return(seg)
      }) |> purrr::reduce(sf:::rbind.sf) # %>% suppressWarnings(mapedit:::combine_list_of_sf(.))
    
    if(buffer == TRUE){
      buf <- seg |> sf::st_as_sf() |> sf::st_buffer(dist = buffer.width, endCapStyle = "FLAT")
      return(list(transects = transects, segments = seg, buffered.segments = buf, bbx = bbx))
    } else{
      return(list(transects = transects, segments = seg, bbx = bbx))
    }
  } else {
    if(buffer == TRUE){
      buf <- transects |> sf::st_as_sf() |> sf::st_buffer(dist = buffer.width, endCapStyle = "FLAT")
      return(list(transects = transects, buffered.transects = buf, bbx = bbx))
    } else {
       return(list(transects = transects, bbx = bbx))
    }    
  }
}
```

```{r examples-generate_survey_plan}
surv <- generate_survey_plan(bbx.xmin = 5, bbx.xmax = 85, bbx.ymin = 5, bbx.ymax = 85,
                             start.x = 10, end.x = 80, start.y = 10, end.y = 80,
                             space.out.factor = 4, segmentize = TRUE, seg.length = 2, 
                             buffer = TRUE, buffer.width = 0.2
                             )
par(mfrow = c(2,2), mar = c(2.5,2.5,4,0.5))
raster::plot(surv$bbx, axes = T, main = "bounding box")
plot(sf::st_geometry(surv$transects), axes = T, main = "transects")
plot(sf::st_geometry(surv$segments), axes = T, main = "segments")
plot(sf::st_geometry(surv$buffered.segments), axes = T, main = "buffered seg")
```

```{r tests-generate_survey_plan}
test_that("generate_survey_plan works", {
  
  expect_error(
    object = generate_survey_plan(bbx.xmin = 5, bbx.xmax = 85, bbx.ymin = 5, bbx.ymax = 85,
                             start.x = 10, end.x = 80, start.y = 10, end.y = 80,
                             space.out.factor = 4, segmentize = TRUE, seg.length = "b",
                             buffer = TRUE, buffer.width = 0.2
                             ),
    regexp = "seg.length must be numeric"
  )
  
  expect_error(
    object = generate_survey_plan(bbx.xmin = 5, bbx.xmax = 85, bbx.ymin = 5, bbx.ymax = 85,
                             start.x = 10, end.x = 80, start.y = 10, end.y = 80,
                             space.out.factor = 4, segmentize = TRUE, seg.length = 2,
                             buffer = TRUE, buffer.width = "b"
                             ),
    regexp = "buffer.width must be numeric"
  )
  
  expect_error(
    object = generate_survey_plan(bbx.xmin = 5, bbx.xmax = 85, bbx.ymin = 5, bbx.ymax = 85,
                             start.x = 10, end.x = 80, start.y = 10, end.y = 80,
                             space.out.factor = 4, segmentize = TRUE, seg.length = 2,
                             buffer = "TRUE", buffer.width = 2
                             ),
    regexp = "buffer must be Boolean"
  )
  
  expect_error(
    object = generate_survey_plan(bbx.xmin = 5, bbx.xmax = 85, bbx.ymin = 5, bbx.ymax = 85,
                             start.x = 10, end.x = 80, start.y = 10, end.y = 80,
                             space.out.factor = 4, segmentize = "TRUE", seg.length = 2,
                             buffer = TRUE, buffer.width = 2
                             ),
    regexp = "segmentize must be Boolean"
  )
  
  expect_error(
    object = generate_survey_plan(bbx.xmin = "5", bbx.xmax = 85, bbx.ymin = 5, bbx.ymax = 85,
                             start.x = 10, end.x = 80, start.y = 10, end.y = 80,
                             space.out.factor = 4, segmentize = TRUE, seg.length = 2,
                             buffer = TRUE, buffer.width = 2
                             ),
    regexp = "bbx.xmin, bbx.xmax, bbx.ymin, bbx.ymax, start.x, end.x, start.y, end.y, space.out.factor must all be numeric"
  )
})
```


# 2. Assign a flight plan to the survey

Before launching a survey, a flight plan must be set up, that is the order by which segments will be surveyed must be chosen. This function gets a segment objects (buffered segments from above), a vector providing the order by which segment table rows will be surveyed, the survey starting date and time, the speed of the aircraft (from which is calculated the survey duration of a single segment) and the duration of the transit period between two successive transects. The function automatically adds a one-second gap between two consecutive segments to avoid overlapping periods. 

```{r function-assign_flight_plan}
#' Assign a flight plan to a survey design
#'
#' @param sf.segments sf object, segments to assign flight plan to
#' @param flight.id numeric vector, giving the order by which the segments must be surveyed
#' @param col.trans.id character, the column in sf.segments storing transect names
#' @param flight.day character, the day the survey flight is carried out (ymd format: "2022-02-08")
#' @param survey.start.hour character, the hour the survey is started (hms format: "06:00:00")
#' @param flight.speed numeric, the speed at which a single segment is surveyed (in km/h)
#' @param intransect.gap.duration numeric, the duration of the transit from a transect to the other (in seconds)
#'
#' @return a sf table with four additional columns (transect.id, flight.id, start.time and end.time) informing the period over which each segment is surveyed
#' @export
#'
#' @examples
assign_flight_plan <- function(
    sf.segments,
    flight.id,
    col.trans.id,
    flight.day, 
    survey.start.hour,
    flight.speed,
    intertransect.gap.duration
){
  # checks
  if(isFALSE( inherits(sf.segments, "sf") )){
    stop("sf.segments must be a sf object")
  }
  if(isFALSE( length(unique(sf::st_geometry_type(sf.segments))) == 1) ){
    stop("sf.segments must include only one geometry type (POLYGON")
  }
  if(isFALSE( unique(sf::st_geometry_type(sf.segments)) == "POLYGON")){
    stop("sf.segments geometry is not of type POLYGON")
  }
  if(isFALSE( length(flight.id) == nrow(sf.segments) )){
    stop("flight.id must be of the same length as sf.segments")
  }
  if(isFALSE( all( is.character(flight.day), is.character(survey.start.hour), is.character(col.trans.id) ) )){
    stop("flight.day, survey.start.hour and col.trans.id must be character")
  }
  if(isFALSE( all( is.numeric(flight.speed), is.numeric(intertransect.gap.duration) ) )){
    stop("flight.speed and intertransect.gap.duration must be numeric")
  }
  if(isFALSE( col.trans.id %in% names(sf.segments) )){
    stop("col.trans.id must be a column of sf.segments")
  }
  
  # function
  seg <- sf.segments
  seg$transect.id <- seg %>% dplyr::pull(col.trans.id)
  seg$flight.id <- flight.id
  
  seg_ord <- seg %>% dplyr::arrange(flight.id)
  
  # compute date time for all segments iteratively, following the flight order
  for(i in 1:length(flight.id)){
    if(i == 1) {
      seg_i <- seg_ord |> subset(flight.id == i) |> sf::st_drop_geometry()
      # if first seg of the first transect, start time is the starting time of the full survey. The duration of a seg is retrieved from the seg length and the survey speed, from which endtime is computed
      starttime <- lubridate::ymd_hms(paste(flight.day, survey.start.hour, sep = " "))
      seg.duration <- (seg_i[, "SegLengthKm"]/flight.speed)*60*60
      endtime <- starttime + lubridate::seconds(seg.duration)
      
      seg_ord[which(seg_ord$flight.id == i), "start.time"] <- starttime
      seg_ord[which(seg_ord$flight.id == i), "end.time"] <- endtime
    } 
    if(i != 1){
      seg_i <- seg_ord |> subset(flight.id == i) |> sf::st_drop_geometry()
      prev_seg <- seg_ord |> subset(flight.id == i-1) |> sf::st_drop_geometry()
      
      if( seg_i[, "transect.id"] != prev_seg[, "transect.id"] ){
        # if a new transect is started, the delay between the current segment and the previous is set to intransect.gap.duration
        starttime <- prev_seg[, "end.time"] + lubridate::seconds(intertransect.gap.duration)
        seg.duration <- (seg_i[, "SegLengthKm"]/flight.speed)*60*60
        endtime <- starttime + lubridate::seconds(seg.duration)
        
        seg_ord[which(seg_ord$flight.id == i), "start.time"] <- starttime
        seg_ord[which(seg_ord$flight.id == i), "end.time"] <- endtime
      } else {
        # otherwise, starttime is computed as the endtime of the previous seg + half a second (to avoid overlap)
        starttime <- prev_seg[, "end.time"] + lubridate::seconds(0.5)
        seg.duration <- (seg_i[, "SegLengthKm"]/flight.speed)*60*60
        endtime <- starttime + lubridate::seconds(seg.duration)
        
        seg_ord[which(seg_ord$flight.id == i), "start.time"] <- starttime
        seg_ord[which(seg_ord$flight.id == i), "end.time"] <- endtime
      }
    }
  }
  return(seg_ord)
}
```

```{r examples-assign_flight_plan}
surv <- generate_survey_plan(bbx.xmin = 5, bbx.xmax = 85, bbx.ymin = 5, bbx.ymax = 85,
                             start.x = 5, end.x = 85, start.y = 5, end.y = 85,
                             space.out.factor = 4, segmentize = TRUE, seg.length = 1, 
                             buffer = TRUE, buffer.width = 0.2
                             )

# Here, set up a flight plan where the first transect is flown in a given 
# direction, the second in the other direction etc, so that the aircraft 
# does not need to go all the way to the other side of the survey area 
# to start a new transect. The intransect.gap.duration is thus set to 1 minute, 
# a the flight speed to 160 km/h (the classical speed for aerial surveys). 
# in that case, the survey duration for a single segment is 22.5 seconds. 
flight.id <- c(1:80, 160:81, 161:240, 320:241, 321:400, 480:401, 481:560, 640:561, 641:720, 800:721, 801:880, 960:881, 961:1040,
                   1120:1041, 1121:1200, 1280:1201, 1281:1360, 1440:1361, 1441:1520, 1600:1521, 1601:1680)

# assign the time periods to each segment
flight_plan <- assign_flight_plan(
    sf.segments = surv$buffered.segments,
    flight.id = flight.id,
    col.trans.id = "transect",
    flight.day = "2022-02-08", 
    survey.start.hour = "06:00:00",
    flight.speed = 160,
    intertransect.gap.duration = 60
)

# plot to check everything is ok
library(ggplot2)
ggplot(flight_plan) +
    geom_sf(aes(fill = start.time),
            color = "black", size = 0.2) +
    scale_fill_datetime(low = "#8073ac", high = "#fdb863") +
    theme_bw() + theme(panel.grid = element_blank()) +
    labs(fill = "Hour", limits = c("06:00", "16:16"), x = "x", y = "y")+
    coord_sf(xlim = c(0,90), ylim = c(0,90))

ggplot(flight_plan) +
    geom_sf(aes(fill = flight.id),
            color = "black", size = 0.2)
```

```{r tests-assign_flight_plan}
test_that("assign_flight_plan works", {
  
  surv <- generate_survey_plan(bbx.xmin = 5, bbx.xmax = 85, bbx.ymin = 5, bbx.ymax = 85,
                             start.x = 5, end.x = 85, start.y = 5, end.y = 85,
                             space.out.factor = 4, segmentize = TRUE, seg.length = 1, 
                             buffer = TRUE, buffer.width = 0.2
                             )

  flight.id <- c(1:80, 160:81, 161:240, 320:241, 321:400, 480:401, 481:560, 640:561, 641:720, 800:721, 801:880, 960:881, 961:1040,
                   1120:1041, 1121:1200, 1280:1201, 1281:1360, 1440:1361, 1441:1520, 1600:1521, 1601:1680)

  expect_error(
    object = assign_flight_plan(
    sf.segments = surv$buffered.segments,
    flight.id = flight.id,
    col.trans.id = "toto",
    flight.day = "2022-02-08", 
    survey.start.hour = "06:00:00",
    flight.speed = 160,
    intertransect.gap.duration = 60),
    regexp = "col.trans.id must be a column of sf.segments"
  )
  
  expect_error(
    object = assign_flight_plan(
    sf.segments = surv$buffered.segments,
    flight.id = flight.id,
    col.trans.id = "transect",
    flight.day = 2022, 
    survey.start.hour = "06:00:00",
    flight.speed = 160,
    intertransect.gap.duration = 60),
    regexp = "flight.day, survey.start.hour and col.trans.id must be character"
  )
  
  expect_error(
    object = assign_flight_plan(
    sf.segments = surv$segments,
    flight.id = flight.id,
    col.trans.id = "transect",
    flight.day = "2022-02-08", 
    survey.start.hour = "06:00:00",
    flight.speed = 160,
    intertransect.gap.duration = 60),
    regexp = "sf.segments geometry is not of type POLYGON"
  )
})

```



# 3. Simulate survey on fixed individual

This function can be used to simulate the detection process when the surveyed individuals are fixed on the geographical space, for example when the species distribution is generated by `simul_spat`. If strip_transect is emulated, an individual is considered detected if its distance to the track line is lower than the width (provided with sigma). If line-transect is emulated, a half-normal detection function is built using the given sigma as effective strip half-width. The user must define if the simulation is done in a virtual space or not (if not, the distances must be provided in km and pts and transects objects must be projected).  


```{r function-detection_process}
#' Detection process on spatial point process
#'
#' This function can be used to simulate the detection process when the surveyed individuals are fixed on the geographical space, for example when the species distribution is generated by `simul_spat`. If strip_transect is emulated, an individual is considered detected if its distance to the track line is lower than the width (provided with sigma). If line-transect is emulated, a half-normal detection function is built using the given sigma as effective strip half-width. The user must define if the simulation is done in a virtual space or not (if not, the distances must be provided in km and pts and transects objects must be projected). 
#'
#' @param pts sf object (points), the position of individuals to be surveyed
#' @param transects sf object (lines), survey layout with transects or segments
#' @param sigma numeric, effective strip half-width (in km, if in real space). If NULL (the default), strip-transect is implemented
#' @param seg.id.col character, the name of the column in transects where the ids are stored
#'
#' @importFrom sf st_distance st_drop_geometry
#' @importFrom glue glue
#' @importFrom stats rbinom dnorm
#'
#' @return the pts dataframe (sf object) with additional columns: distance, distance_km (if in real space), segID (the closest transect or segment from the individual) and detected (1 if the individual is detected, 0 otherwise)
#' @export
#'
#' @examples
detection_process <- function(pts, 
                              transects, 
                              strip.transect = TRUE,
                              sigma = NULL, 
                              seg.id.col = NULL, 
                              virtual.space = TRUE) {
  if(isFALSE(all(inherits(pts, "sf"), inherits(transects, "sf")))){
    stop("pts and transects must be sf objects")
  }
  if(isFALSE(length(unique(sf::st_geometry_type(pts))) == 1)){
    stop("pts must include only one geometry type (POINT)")
  }
  if(isFALSE(unique(sf::st_geometry_type(pts)) == "POINT")){
    stop("pts geometry is not of type POINT")
  }
  if(isFALSE(length(unique(sf::st_geometry_type(transects))) == 1)){
    stop("transects must include only one geometry type (LINESTRING)")
  }
  if(isFALSE(unique(sf::st_geometry_type(transects)) == "LINESTRING")){
    stop("transects geometry is not of type LINESTRING")
  }
  if(isTRUE(is.null(seg.id.col))){
    stop("seg.id.col must be provided")
  } else {
    transects$segID <- sf::st_drop_geometry(transects[,seg.id.col]) %>% unlist()  
  }
  if(isFALSE(is.numeric(sigma))){
    stop("sigma must be numeric")
  }
  
  ## compute distance with st_distance
  if(isTRUE(virtual.space)){
    dist_mat <- sf::st_distance(
                  x = pts,
                  y = transects)
    pts$distance <- apply(dist_mat, 1, min)
    pts$closest.seg <- apply(dist_mat, 1, function(x) min(which(x == min(x, na.rm = TRUE))))
    pts$segID <- transects$segID[pts$closest.seg]  
    
    ## detection process
    if(isTRUE(strip.transect)) {
      message(glue::glue("Strip-transect is used with a width of {sigma}"))
      esw <- sigma
      pts$detected <- ifelse(pts$distance <= esw, 1, 0)
    } else {
      message(glue::glue("Line-transect is used with a effective half width of {sigma}"))
      esw <- (pnorm(+Inf, 0, sigma) - 0.5) / dnorm(0, 0, sigma)
      proba <- exp(- (pts$distance)^2 / (2 * sigma * sigma))
      pts$detected <- rbinom(nrow(pts), size = 1, prob = proba)
    }
    return(pts)
  } else {
    dist_mat <- sf::st_distance(
                  x = pts,
                  y = transects)
    pts$distance <- apply(dist_mat, 1, min)
    pts$distance_km <- pts$distance / 1e3
    pts$closest.seg <- apply(dist_mat, 1, function(x) min(which(x == min(x, na.rm = TRUE))))
    pts$segID <- transects$segID[pts$closest.seg]
    
    ## detection process
    if(isTRUE(strip.transect)) {
      message(glue::glue("Strip-transect is used with a width of {sigma}"))
      esw <- sigma
      pts$detected <- ifelse(pts$distance_km <= esw, 1, 0)
    } else {
      message(glue::glue("Line-transect is used with a effective half width of {sigma}"))
      esw <- (pnorm(+Inf, 0, sigma) - 0.5) / dnorm(0, 0, sigma)
      proba <- exp(- (pts$distance_km)^2 / (2 * sigma * sigma))
      pts$detected <- rbinom(nrow(pts), size = 1, prob = proba)
    }
    return(pts)
  }
}
```

```{r examples-detection_process}
grid <- create_grid()
env <- generate_env_layer(grid = grid)
sp <- simul_spat(ref_map = env$rasters$sim1,N = 1000, n_sim = 1, return_wgs_coordinates = F)
surv <- generate_survey_plan(bbx.xmin = 5, bbx.xmax = 85, bbx.ymin = 5, bbx.ymax = 85,
                             start.x = 10, end.x = 80, start.y = 10, end.y = 80,
                             space.out.factor = 4, segmentize = TRUE, seg.length = 2, 
                             buffer = TRUE, buffer.width = 0.2
                             )

pts <- detection_process(pts = sp, 
                         transects = surv$segments, 
                         strip.transect = TRUE, 
                         sigma = 0.2, 
                         virtual.space = TRUE,
                         seg.id.col = "seg.id")
plot(sp$x, sp$y)
# plot(sf::st_geometry(surv$buffered.segments), border = "pink", color = NA, add = T)
plot(sf::st_geometry(surv$segments), col = "red", add = T)
points(sf::st_drop_geometry(pts[which(pts$detected == 1), c("x", "y")]), axes = T, pch = 20, col = "blue")
```

```{r tests-detection_process}
test_that("detection_process works", {
  grid <- create_grid()
  env <- generate_env_layer(grid = grid)
  sp <- suppressWarnings(simul_spat(ref_map = env$rasters$sim1,N = 1000, n_sim = 1, return_wgs_coordinates = F))
  surv <- generate_survey_plan(bbx.xmin = 5, bbx.xmax = 85, bbx.ymin = 5, bbx.ymax = 85,
                             start.x = 10, end.x = 80, start.y = 10, end.y = 80,
                             space.out.factor = 4, segmentize = TRUE, seg.length = 2, 
                             buffer = TRUE, buffer.width = 0.2
                             )
  
  expect_error(
    object = detection_process(pts = sp, 
                         transects = surv$segments, 
                         strip.transect = TRUE, 
                         sigma = 0.2, 
                         virtual.space = TRUE),
    regexp = "seg.id.col must be provided")
  
  expect_error(
    object = detection_process(pts = "sp", 
                         transects = surv$segments, 
                         strip.transect = TRUE, 
                         sigma = 0.2, 
                         virtual.space = TRUE),
    regexp = "pts and transects must be sf objects")
  
  expect_error(
    object = detection_process(pts = sp, 
                         transects = sp, 
                         strip.transect = TRUE, 
                         sigma = 0.2, 
                         virtual.space = TRUE),
    regexp = "transects geometry is not of type LINESTRING")
} )
```


# 3. Simulate survey on moving individuals





```{r development-inflate, eval=FALSE}
# Run but keep eval=FALSE to avoid infinite loop
# Execute in the console directly
fusen::inflate(flat_file = "dev/flat_simulate_survey.Rmd", vignette_name = "Simulate survey")
```

