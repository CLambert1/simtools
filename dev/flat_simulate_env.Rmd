---
title: "flat_simulate_env.Rmd for working package"
output: html_document
editor_options: 
  chunk_output_type: console
---

<!-- Run this 'development' chunk -->
<!-- Store every call to library() that you need to explore your functions -->

```{r development, include=FALSE}
# library(geoR)
# 
# sim1 <- grf(100, cov.pars = c(1, .25))
# # a display of simulated locations and values
# points(sim1)   
# # empirical and theoretical variograms
# plot(sim1)
# ## alternative way
# plot(variog(sim1, max.dist=1))
# lines.variomodel(sim1)
# #
# # a "smallish" simulation
# sim2 <- grf(441, grid = "reg", cov.pars = c(1, .25)) 
# image(sim2)
# 
# tt <- grf(grid = as.matrix(grid), n = 32761, xlims = c(0,90), ylims = c(0,90),
#           cov.pars = c(1, .25), lambda = 1)
# image(tt)
# 
# ## simulating within borders
# data(parana)
# pr1 <- grf(100, cov.pars=c(200, 40), borders=parana$borders, mean=500)
# points(pr1)
# pr1 <- grf(100, grid="reg", cov.pars=c(200, 40), borders=parana$borders)
# points(pr1)
# pr1 <- grf(100, grid="reg", nx=10, ny=5, cov.pars=c(200, 40), borders=parana$borders)
# points(pr1)
# 

```


```{r development-load}
# Load already included functions if relevant
pkgload::load_all(export_all = FALSE)
```

# Create the grid

Create the grid structuring the virtual environment. By default, `create_grid` creates a grid spanning 0 to 90Â° in both longitude and latitude, with steps of 0.5. 

```{r function-create_grid}
#' Create the grid of a virtual environment
#'
#' @param ymin Minimum latitude (default to 0)
#' @param ymax Maximum latitude (default to 90)
#' @param xmin Minimum longitude (default to 0)
#' @param xmax Maximum latitude (default to 90)
#' @param step_x Longitude steps to be used to generate points (default to 0.5)
#' @param step_y Latitude steps to be used to generate points (default to 0.5)
#'
#' @return A grid in dataframe format. 
#' @export
#'
#' @examples
create_grid <- function(ymin = 0, ymax = 90, xmin = 0, xmax = 90, step_x = 0.5, step_y = 0.5){
  xy <- expand.grid(seq(xmin, xmax, step_x), seq(xmin, ymax, step_y))
  colnames(xy) <- c("x","y")
  return(xy)
}
```
  
```{r example-create_grid}
grid <- create_grid()
```
  
```{r tests-create_grid}
test_that("create_grid works", {
  expect_true(inherits(create_grid, "function")) 
  expect_true(inherits(create_grid(), "data.frame")) 
})
```
  

# Generating environmental layers

The `generate_env_layer` function creates several environmental layers using Gaussian simulation from the grid locations. The number of layers generated is set by n. The generated layers can be normalised, and be returned either only as data frame or both in data frame and raster formats (SpatRast). 


```{r function-generate_env_layer}
#' Generating random environmental layers
#'
#' @param seed Value to feed set.seed (default 2)
#' @param grid Grid of the virtual space, as generated by \code{\link{create_grid}}
#' @param n Number of layers to be generated (default 2)
#' @param beta The beta value to be forwarded to gstat (default to 1)
#' @param norm Should the resulting layers be normalized? 
#' @param return_rasters Should the function returns SpatRast in addition to data frame?
#'
#' @return Returns a data frame with the simulated environmental values, as well as SpatRast is return_rasters = TRUE
#' @export
#' 
#' @family environment simulation functions
#' 
#' @importFrom gstat gstat vgm
#' @importFrom terra rast
#' @importFrom stats predict
#' 
#' @examples
generate_env_layer <- function(seed = 2, 
                               grid, 
                               n = 2, 
                               beta = 1, 
                               norm = TRUE, 
                               return_rasters = TRUE){
  set.seed(seed)
  field <- gstat::gstat(formula = z~1, locations = ~x+y, dummy = TRUE, beta = beta, 
                 model = gstat::vgm(psill = 100, range = 100, model = 'Exp'), nmax = 20)
  cov <- predict(field, newdata = grid, nsim = n)
  
  if(norm == TRUE){
    for(i in 1:n){
      cov[,2+i] <- normalize(cov[, 2+i])
    }
    if(return_rasters == TRUE){
      rast_stack <- terra::rast(x = cov, type = "xyz")
      return(list(dataframe = cov, rasters = rast_stack))
    } else {
      return(cov)
    }
  } else {
    if(return_rasters == TRUE){
      rast_stack <- terra::rast(x = cov, type = "xyz")
      return(list(dataframe = cov, rasters = rast_stack))
    } else {
      return(cov)
    }
  }
}

```
  
```{r example-generate_env_layer}
grid <- create_grid()

str(generate_env_layer(norm = FALSE, return_rasters = FALSE, grid = grid))
str(generate_env_layer(norm = TRUE, return_rasters = FALSE, grid = grid))

library(terra)
plot(generate_env_layer(norm = TRUE, return_rasters = TRUE, grid = grid)$rasters)
plot(generate_env_layer(norm = FALSE, return_rasters = TRUE, grid = grid)$rasters)
```
  
```{r tests-generate_env_layer}
test_that("generate_env_layer works", {

  grid <- create_grid()
  output <- generate_env_layer(norm = FALSE, return_rasters = FALSE, grid = grid)

  expect_true(inherits(output, "data.frame"))

  expect_true(length(generate_env_layer(grid = grid)) == 2)
})
```
  

# Build the suitability layer

The `generate_resource_layer` function permits building a suitability layer from a set of environmental layers and beta parameters to be leveraged with. It mimics a basic resource selection function, where a given environmental layer is simply scaled by the beta parameter (env*beta) and several leveraged env layers are additively combined. For more elaborate procedures, see the [virtualspecies package](https://borisleroy.com/files/virtualspecies-tutorial.html).

    
```{r function-generate_resource_layer}
#' Resource selection function
#'
#' @param beta The beta values to multiply the environmental layers with (must be as much beta as layers)
#' @param env_layers Environmental layers to build the resource from. Can either be a data frame (including map coordinates and environmental layer values) or a SpatRast. 
#' @param coordinate_fields If env_layers is a data frame, the fields corresponding to the map coordinates (e.g. c("x", "y"), the default)
#' @param norm Should the resource layer be normalized? 
#' @param return_rasters Should the function returns the resource as SpatRast in addition to the data frame?

#' @importFrom dplyr select
#' @importFrom purrr reduce
#' @importFrom terra rast
#' 
#' @return Returns a data frame with the suitability layer, as well as SpatRast is return_rasters = TRUE
#' @export
#' 
#' @family environment simulation functions
#'
#' @examples
generate_resource_layer <- function(beta, env_layers, coordinate_fields = c("x", "y"), norm = TRUE, return_rasters = TRUE){
  # check input format
  if(isFALSE(class(env_layers) %in% c("SpatRaster", "data.frame"))){
    stop("env_layers must be of class SpatRast or data.frame")
  }
  ##### Better TRY INHERITS OR IS()
  
  # convert the env_layers into a dataframe if a raster is provided, use as is otherwise
  if(inherits(env_layers, "data.frame")){
    xy <- env_layers[, coordinate_fields]
    env_cdts <- env_layers |> dplyr::select(!(dplyr::all_of(coordinate_fields))) }  
  
  if(inherits(env_layers, "SpatRaster")){
    xy <- as.data.frame(env_layers, xy = T)[, c("x", "y")]
    env_cdts <- as.data.frame(env_layers) }
  
  # check beta provides as much values as there is layers in env_layers
  if(isFALSE(length(beta) == ncol(env_cdts))) {
    stop("There must be as much beta parameters than env_layers to be used to generate the resource layer.")
  }
  
  # compute the resource layer from the conditions and beta parameters
  suitability <- lapply(1:ncol(env_cdts), function(i){
    env_cdts[,i]*beta[i]
  })  |> purrr::reduce(`+`) 
  # same but farr longer: rsce |> dplyr::rowwise() |> dplyr::mutate(Suitability = sum(dplyr::c_across(dplyr::contains("sim"))))
  
  resource_layer <- cbind(xy, suitability)
    
  # normalize the result or not?
  if(norm == TRUE){
    resource_layer$suitability <- normalize(resource_layer$suitability)
    
    if(return_rasters == TRUE){
      rsce_rast <- terra::rast(x = resource_layer, type = "xyz")
      
      return(list(dataframe = resource_layer, rasters = rsce_rast))
    } else {
      return(resource_layer)
    }
  } else {
    if(return_rasters == TRUE){
      rsce_rast <- terra::rast(x = resource_layer, type = "xyz")
      
      return(list(dataframe = resource_layer, rasters = rsce_rast))
    } else {
      
      return(resource_layer)
    }
  }
}
```
  
```{r example-generate_resource_layer}
library(terra)
# simple example
grid <- create_grid()
cdt <- generate_env_layer(grid = grid)
rsce <- generate_resource_layer(env_layers = cdt$rasters,
                            beta = c(2, -1.5))
str(rsce)
plot(rsce$rasters)

# also works when coordinates are not names x,y
cdt2 <- generate_env_layer(grid = grid, n = 3)$dataframe |> dplyr::rename(lon = x, lat = y)
str(generate_resource_layer(env_layers = cdt2, coordinate_fields = c("lon", "lat"),
                            beta = c(2, -1.5, 3)) )
```
  
```{r tests-generate_resource_layer}
test_that("generate_resource_layer works", {
  expect_true(inherits(generate_resource_layer, "function"))

  grid <- create_grid()
  env_condition <- generate_env_layer(grid = grid)

  expect_error(
    object = generate_resource_layer(env_layers = env_condition$dataframe, beta = 2),
    regexp = "There must be as much beta parameters than env_layers to be used to generate the resource layer."
  )

  expect_error(
    object = generate_resource_layer(env_layers = "toto", beta = 2),
    regexp = "env_layers must be of class SpatRast or data.frame"
  )
})
```
  



```{r development-inflate, eval=FALSE}
# Keep eval=FALSE to avoid infinite loop in case you hit the knit button
# Execute in the console directly
fusen::inflate(flat_file = "dev/flat_simulate_env.Rmd", 
               vignette_name = "Simulate virtual environment", 
               overwrite = T, check = FALSE)
```

